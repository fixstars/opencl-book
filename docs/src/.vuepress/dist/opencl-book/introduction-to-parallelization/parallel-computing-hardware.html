<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Parallel Computing (Hardware) | OpenCL Book</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#2492f3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/opencl-book/assets/css/0.styles.1c7709fb.css" as="style"><link rel="preload" href="/opencl-book/assets/js/app.34c20c2e.js" as="script"><link rel="preload" href="/opencl-book/assets/js/2.4b9f7fec.js" as="script"><link rel="preload" href="/opencl-book/assets/js/5.47683efd.js" as="script"><link rel="prefetch" href="/opencl-book/assets/js/10.b635290b.js"><link rel="prefetch" href="/opencl-book/assets/js/11.c0ed33a0.js"><link rel="prefetch" href="/opencl-book/assets/js/12.23abdb80.js"><link rel="prefetch" href="/opencl-book/assets/js/13.b88b0061.js"><link rel="prefetch" href="/opencl-book/assets/js/14.e0f12f95.js"><link rel="prefetch" href="/opencl-book/assets/js/15.db0c382e.js"><link rel="prefetch" href="/opencl-book/assets/js/16.e7b0bbcf.js"><link rel="prefetch" href="/opencl-book/assets/js/17.5fc1ea84.js"><link rel="prefetch" href="/opencl-book/assets/js/18.b358550b.js"><link rel="prefetch" href="/opencl-book/assets/js/19.6f2b05fe.js"><link rel="prefetch" href="/opencl-book/assets/js/20.23add722.js"><link rel="prefetch" href="/opencl-book/assets/js/21.d75f5fbe.js"><link rel="prefetch" href="/opencl-book/assets/js/22.b98ab071.js"><link rel="prefetch" href="/opencl-book/assets/js/23.6529153b.js"><link rel="prefetch" href="/opencl-book/assets/js/24.972fe0d7.js"><link rel="prefetch" href="/opencl-book/assets/js/25.e100e017.js"><link rel="prefetch" href="/opencl-book/assets/js/26.ae7fe068.js"><link rel="prefetch" href="/opencl-book/assets/js/27.ccf814e4.js"><link rel="prefetch" href="/opencl-book/assets/js/28.c467ee16.js"><link rel="prefetch" href="/opencl-book/assets/js/29.6690f000.js"><link rel="prefetch" href="/opencl-book/assets/js/3.87c07e7d.js"><link rel="prefetch" href="/opencl-book/assets/js/30.72f82acf.js"><link rel="prefetch" href="/opencl-book/assets/js/31.6c8aaa12.js"><link rel="prefetch" href="/opencl-book/assets/js/32.8f1dcdbc.js"><link rel="prefetch" href="/opencl-book/assets/js/33.a644cfe5.js"><link rel="prefetch" href="/opencl-book/assets/js/34.e63ef5ea.js"><link rel="prefetch" href="/opencl-book/assets/js/35.b29ee815.js"><link rel="prefetch" href="/opencl-book/assets/js/4.36850638.js"><link rel="prefetch" href="/opencl-book/assets/js/6.f687cbd5.js"><link rel="prefetch" href="/opencl-book/assets/js/7.61d32e36.js"><link rel="prefetch" href="/opencl-book/assets/js/8.1076ef6a.js"><link rel="prefetch" href="/opencl-book/assets/js/9.754eb4e4.js">
    <link rel="stylesheet" href="/opencl-book/assets/css/0.styles.1c7709fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/opencl-book/" class="home-link router-link-active"><!----> <span class="site-name">OpenCL Book</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/opencl-book/opencl-book/" class="nav-link router-link-active">
  OpenCL Book
</a></div><div class="nav-item"><a href="https://us.fixstars.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Fixstars Solutions
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/opencl-book/opencl-book/" class="nav-link router-link-active">
  OpenCL Book
</a></div><div class="nav-item"><a href="https://us.fixstars.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Fixstars Solutions
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/opencl-book/opencl-book/" aria-current="page" class="sidebar-link">Foreword</a></li><li><a href="/opencl-book/opencl-book/who-should-read-this-book.html" class="sidebar-link">Who Should Read this Book?</a></li><li><a href="/opencl-book/opencl-book/about-the-authors.html" class="sidebar-link">About the Authors</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Introduction to Parallelization</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/why-parallelization.html" class="sidebar-link">Why Parallelization</a></li><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html" aria-current="page" class="active sidebar-link">Parallel Computing Hardware</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html#flynn-s-taxonomy" class="sidebar-link">Flynn's Taxonomy</a></li><li class="sidebar-sub-header"><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html#distributed-memory-type" class="sidebar-link">Distributed Memory Type</a></li><li class="sidebar-sub-header"><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html#shared-memory-type" class="sidebar-link">Shared Memory Type</a></li><li class="sidebar-sub-header"><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html#accelerator" class="sidebar-link">Accelerator</a></li></ul></li><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-software.html" class="sidebar-link">Parallel Computing Software</a></li><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/conclusion.html" class="sidebar-link">Conclusion</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/opencl/what-is-opencl.html" class="sidebar-link">What is OpenCL?</a></li><li><a href="/opencl-book/opencl-book/opencl/historical-background.html" class="sidebar-link">Historical Background</a></li><li><a href="/opencl-book/opencl-book/opencl/an-overview-of-opencl.html" class="sidebar-link">An Overview of OpenCL</a></li><li><a href="/opencl-book/opencl-book/opencl/why-opencl.html" class="sidebar-link">Why OpenCL?</a></li><li><a href="/opencl-book/opencl-book/opencl/applicable-platforms.html" class="sidebar-link">Applicable Platforms</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>OpenCL Setup</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/opencl-setup/available-opencl-environments.html" class="sidebar-link">Available OpenCL Environments</a></li><li><a href="/opencl-book/opencl-book/opencl-setup/development-environment-setup.html" class="sidebar-link">Development Environment Setup</a></li><li><a href="/opencl-book/opencl-book/opencl-setup/first-opencl-program.html" class="sidebar-link">First OpenCL Program</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Basic OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/basic-opencl/basic-program-flow.html" class="sidebar-link">Basic Program Flow</a></li><li><a href="/opencl-book/opencl-book/basic-opencl/online-offline-compilation.html" class="sidebar-link">Online/Offline Compilation</a></li><li><a href="/opencl-book/opencl-book/basic-opencl/calling-the-kernel.html" class="sidebar-link">Calling the Kernel</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Advanced OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/advanced-opencl/opencl-c.html" class="sidebar-link">OpenCL C</a></li><li><a href="/opencl-book/opencl-book/advanced-opencl/opencl-programming-practice.html" class="sidebar-link">OpenCL Programming Practice</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Changes made in OpenCL Specification 1.2</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.0-to-1.1.html" class="sidebar-link">Changes made in update from 1.0 to 1.1</a></li><li><a href="/opencl-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html" class="sidebar-link">Changes made in update from 1.1 to 1.2</a></li></ul></section></li><li><a href="/opencl-book/opencl-book/references.html" class="sidebar-link">References</a></li><li><a href="/opencl-book/opencl-book/notes.html" class="sidebar-link">Notes</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="parallel-computing-hardware"><a href="#parallel-computing-hardware" class="header-anchor">#</a> Parallel Computing (Hardware)</h1> <p>First of all, what exactly is &quot;parallel computing&quot;? Wikipedia defines it as 'a form of computation in which many calculations are carried out simultaneously, operating on the principle that large problems can often be divided into smaller ones, which are then solved concurrently (&quot;in parallel&quot;)'. [1]</p> <p>Many different hardware architectures exist today that can perform a single task using multiple processors. Some examples, in order of decreasing scale are:</p> <p><strong>Grid computing</strong> - a combination of computer resources from multiple administrative domains applied to a common task.</p> <p><strong>MPP (Massively Parallel Processor) systems</strong> - known as the supercomputer architecture.</p> <p><strong>Cluster server system</strong> - a network of general-purpose computers.</p> <p><strong>SMP (Symmetric Multiprocessing) system</strong> - identical processors (grouped in powers of 2) connected together to act as one unit.</p> <p><strong>Multi-core processor</strong> - a single chip with numerous computing cores.</p> <h2 id="flynn-s-taxonomy"><a href="#flynn-s-taxonomy" class="header-anchor">#</a> <em>Flynn's Taxonomy</em></h2> <p>Flynn's Taxonomy is a classification of computer architectures proposed by Michael J. Flynn [2]. It is based on the concurrency of instruction and data streams available in the architecture. An instruction stream is the set of instructions that makes up a process, and a data stream is the set of data to be processed.</p> <p><strong>1. Single Instruction, Single Data stream (SISD)</strong></p> <p>SISD system is a sequential system where one instruction stream process one data stream. The pre-2004 PCs were of this type of system.</p> <p><strong>Figure 1.2: SISD architecture</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.03.42_AM.b8540c16.png" alt=""></p> <p><strong>2. Single Instruction, Multiple Data streams (SIMD)</strong></p> <p>One instruction is broadcasted across many compute units, where each unit processes the same instruction on different data. The vector processor, a type of supercomputer, is an example of this type of architecture. Recently, various micro-processors include SIMD processors. For example, SSE/AVX instructions on Intel CPUs, and SPE instructions on Cell Broadband Engines perform SIMD operations.</p> <p><strong>Figure 1.3: SIMD architecture</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.02.36_AM.792ef9d9.png" alt=""></p> <p><strong>3. Multiple Instruction, Single Data stream (MISD)</strong></p> <p>Multiple instruction streams process a single data stream. Very few systems fit within this category, with the exception of fault tolerant systems.</p> <p><strong>4. Multiple Instruction, Multiple Data streams (MIMD)</strong></p> <p>Multiple processing units each process multiple data streams using multiple instruction streams.</p> <p><strong>Figure 1.4: MIMD architecture</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.05.16_AM.e133275e.png" alt=""></p> <p>Using this classification scheme, most parallel computing hardware architectures, such as the SMP and cluster systems, fall within the MIMD category. For this reason, the MIMD architecture is further categorized by memory types.</p> <p>The two main memory types used in parallel computing system are shared memory and distributed memory types. In shared memory type systems, each CPU that makes up the system is allowed access to the same memory space. In distributed memory type systems, each CPU that makes up the system uses a unique memory space.</p> <p>Different memory types result in different data access methods. If each CPU is running a process, a system with shared memory type allows the two processes to communicate via read/write operations to the shared memory space. On the other hand, a system with distributed memory type requires data transfers to be explicitly performed by the user, since the two memory spaces are managed by two OS's.</p> <p>The next sections explore the two parallel systems in detail.</p> <p><strong>Figure 1.5: The two widely used parallel processing system types</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.23.38_AM.15122021.png" alt=""></p> <h2 id="distributed-memory-type"><a href="#distributed-memory-type" class="header-anchor">#</a> <em>Distributed Memory Type</em></h2> <p>Tasks that take too long using one computer can be broken up to be performed in parallel using a network of processors. This is known as a cluster server system, which is perhaps the most commonly-seen distributed memory type system. This type of computing has been used for years in the HPC (High Performance Computing) field, which performs tasks such as large-scale simulations.</p> <p>MPP (Massively Parallel Processor) system is also another commonly-seen distributed memory type system. It connects numerous nodes, which are made up of CPUs, memory, and a network port, connected via a specialized fast network. NEC's Earth Simulator and IBM's Blue Gene are some of the known MPP systems.</p> <p>The main difference between a cluster system and a MPP system lies in the fact that a cluster does not use specialized hardware, giving it a much higher cost performance than the MPP systems. Due to this reason, many MPP systems, which used to be the leading supercomputer type, have been replaced by cluster systems. According to the TOP500 Supercomputer Sites [3], of the top 500 supercomputers as of June 2009, 17.6% are MPP systems, while 82% are cluster systems.</p> <p><strong>Figure 1.6: Architecture statistics from TOP500 Supercomputer Sites</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.26.27_AM.03ad184e.png" alt=""></p> <p>One problem with cluster systems is the slow data transfer rates between the processors. This is due to the fact that these transfers occur via an external network. Some recent external networks include Myrinet, Infiniband, and 10Gbit Ethernet, which have become significantly faster compared to the traditional Gigabit Ethernet. However, even with these external networks, the transfer rates are still at least an order of magnitude slower than local memory access of each processor.</p> <p>For the reason given above, cluster systems are suited for parallel algorithms where the CPUs do not have to communicate with each other too often. These types of algorithms are said to be &quot;coarse-grained parallel&quot;. These algorithms are used often in simulations where many trials are required, but these trials do not depend on each other. An example of this is risk simulation used for the development of derivative products in the field of finance**.**</p> <h2 id="shared-memory-type"><a href="#shared-memory-type" class="header-anchor">#</a> <em>Shared Memory Type</em></h2> <p>In shared memory type systems, all processors share the same address space, allowing these processors to communicate with each other through read/writes to shared memory. Since data transfers/collections are unnecessary, this results in a much simpler system from the software perspective.</p> <p>An example of a shared memory type system is the Symmetric Multiprocessing (SMP) system (<strong>Figure 1.7</strong>, left/[4]). The Intel Multiprocessor Specification Version 1.0 released back in 1994 describes the method for using x86 processors in a multi-processor configuration. 2-way workstations (where up to 2 CPUs can be installed) are commonly seen today [5]. However, increasing the number of processors naturally increases the number of accesses to the memory, making the bandwidth between the processors and the shared memory a bottleneck. SMP systems are thus not scalable, and only effective up to a certain number of processors. Although 2-way servers are inexpensive and common, 32-way or 64-way SMP servers require specialized hardware, which can become expensive.</p> <p><strong>Figure 1.7: SMP and NUMA</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.28.21_AM.57091abf.png" alt=""></p> <p>Another example of a shared memory type system is the Non-Uniform Memory Access (NUMA) system. The main difference from a SMP system is that the physical distance between the processor and the memory changes the access speeds. By prioritizing the usage of physically closer memory (local memory) over more distant memory (remote memory), the bottleneck in SMP systems can be minimized. To reduce the access cost to remote memory, a processor cache and a specialized hardware making sure the cache data is coherent has been added, and this system is known as a Cash Coherent NUMA (cc-NUMA).</p> <p>Server CPUs such as AMD Opteron and Intel Xeon 5500 Series contain on-chip memory controllers. Thus, when these are used in multi-processor configurations, they become a NUMA system. The hardware to verify cache coherency is embedded into the CPU. In addition, NUMA replaces the Front Side Bus (FSB), which is a bus that connects multiple CPUs as well as other chipsets together, with an interconnect port that uses a point-to-point protocol. These ports are called Quick Path Interconnect (QPI) by Intel, and Hyper Transport by AMD.</p> <p>Now that the basic concepts of SMP and NUMA are covered, let us look at an interesting fact of typical x86 server products. Dual-core and quad-core processors are SMP systems, since the processor cores all access the same memory space. Networking these multi-core processors actually end up creating a NUMA system. In other words, the mainstream 2-way or more x86 server products are &quot;NUMA systems made from SMP systems&quot; (<strong>Figure 1.8</strong>).</p> <p><strong>Figure 1.8: Typical 2-way x86 server</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.30.59_AM.4d8cab11.png" alt=""></p> <h2 id="accelerator"><a href="#accelerator" class="header-anchor">#</a> <em>Accelerator</em></h2> <p>The parallel processing systems discussed in the previous sections are all made by connecting generic CPUs. Although this is an intuitive solution, another approach is to use as co-processor different hardware more suited for performing certain tasks. The non-CPU hardware in this configuration is known as an &quot;accelerator&quot;.</p> <p><strong>Figure 1.9: Example of accelerators</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.33.04_AM.68f4d370.png" alt=""></p> <p>Some popular accelerators include the Cell Broadband Engine (Cell/B.E.) and GPUs. Accelerators typically contain cores optimized for performing floating-point arithmetic (or fixed-point arithmetic for some DSPs). Since these cores are relatively simple and thus do not take much space on the chip, numerous cores are typically available.</p> <p>For example, the Cell/B.E. contains 1 PowerPC Processor Element (PPE), which is suited for processes requiring frequent thread switching, and 8 Synergistic Processor Elements (SPE) which are cores optimized for floating-point arithmetic. These 9 cores are connected using a high-speed bus called the Element Interconnect Bus (EIB), and placed on a single chip**.**</p> <p><strong>Figure 1.10: Architecture of the Cell Broadband Engine</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.34.06_AM_(1).c44870a1.png" alt=""></p> <p>Another example is NVIDIA's Tesla M2000, which is based on a GPU architecture known as Fermi. This chip contains 16 sets of 32-core Streaming Processors (SM), for a total of 512 cores on one chip.</p> <p><strong>Figure 1.11: NVIDIA Fermi architecture</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.35.39_AM.e786afff.png" alt=""></p> <p>In recent years, these accelerators have been attracting a lot of attention. This is mainly due to t he fact that the floating-point arithmetic capability of generic CPUs has leveled off at around 10 GFLOPS, while the Cell/B.E. and GPUs can perform between 100 GFLOPS and 1 TFLOPS for a relatively low price. They are also &quot;greener&quot;, making them a better option than cluster server systems, as many factories and research labs are trying to cut back on power usage.</p> <p>For example, the circuit board and semiconductor fields use automatic visual inspection. The tests increase in number and complexity every year, requiring faster image processing so that the rate of production is not compromised. Medical imaging devices such as ultrasonic diagnosing devices and CT scanners are producing every year higher and higher quality 2-D images as output, and generic CPUs are not capable of processing the images in a practical amount of time. Using a cluster server for these tasks requires a vast amount of space, as well as high power usage. Thus, the accelerators provide a portable and energy-efficient alternative to the cluster. These accelerators are typically used in conjunction with generic CPUs, creating what is known as a &quot;hybrid system&quot;.</p> <p><strong>Figure 1.12: Hybrid system</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2021-12-20_at_8.36.30_AM.b437b96f.png" alt=""></p> <p>In summary, an accelerator allows for a low-cost, low-powered, and high-performance system. However, the transfer speed between the host CPU and the accelerator can become a bottleneck, making it unfit for applications requiring frequent I/O operations. Thus, the decision to use a hybrid system, as well as what type of hybrid system, needs to be made wisely.</p> <p>OpenCL, in brief, is a development framework to write applications that runs on these &quot;hybrid systems&quot;.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/opencl-book/opencl-book/introduction-to-parallelization/why-parallelization.html" class="prev">
        Why Parallelization
      </a></span> <span class="next"><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-software.html">
        Parallel Computing Software
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/opencl-book/assets/js/app.34c20c2e.js" defer></script><script src="/opencl-book/assets/js/2.4b9f7fec.js" defer></script><script src="/opencl-book/assets/js/5.47683efd.js" defer></script>
  </body>
</html>
