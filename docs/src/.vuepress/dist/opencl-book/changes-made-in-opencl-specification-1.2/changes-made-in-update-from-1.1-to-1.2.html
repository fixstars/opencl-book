<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Changes made in update from 1.1 to 1.2 | OpenCL Book</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="This section will highlight the changes made between the 1.1 and 1.2 specifications. In particular, changes in the platform layer/runtime, OpenCL C, and deprecated functions will be discussed.">
    <meta name="theme-color" content="#2492f3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/test-book/assets/css/0.styles.79946ec9.css" as="style"><link rel="preload" href="/test-book/assets/js/app.b513c2d8.js" as="script"><link rel="preload" href="/test-book/assets/js/2.8dbd29eb.js" as="script"><link rel="preload" href="/test-book/assets/js/16.e7b0bbcf.js" as="script"><link rel="prefetch" href="/test-book/assets/js/10.b635290b.js"><link rel="prefetch" href="/test-book/assets/js/11.c0ed33a0.js"><link rel="prefetch" href="/test-book/assets/js/12.7e83236b.js"><link rel="prefetch" href="/test-book/assets/js/13.5fb1d917.js"><link rel="prefetch" href="/test-book/assets/js/14.90f24845.js"><link rel="prefetch" href="/test-book/assets/js/15.db0c382e.js"><link rel="prefetch" href="/test-book/assets/js/17.e1d44dc5.js"><link rel="prefetch" href="/test-book/assets/js/18.b358550b.js"><link rel="prefetch" href="/test-book/assets/js/19.b36a0ae6.js"><link rel="prefetch" href="/test-book/assets/js/20.7c7e8734.js"><link rel="prefetch" href="/test-book/assets/js/21.4aa9dac7.js"><link rel="prefetch" href="/test-book/assets/js/22.b98ab071.js"><link rel="prefetch" href="/test-book/assets/js/23.6529153b.js"><link rel="prefetch" href="/test-book/assets/js/24.7db70101.js"><link rel="prefetch" href="/test-book/assets/js/25.4e203b3a.js"><link rel="prefetch" href="/test-book/assets/js/26.ae7fe068.js"><link rel="prefetch" href="/test-book/assets/js/27.8a49061d.js"><link rel="prefetch" href="/test-book/assets/js/28.c467ee16.js"><link rel="prefetch" href="/test-book/assets/js/29.51098aba.js"><link rel="prefetch" href="/test-book/assets/js/3.87c07e7d.js"><link rel="prefetch" href="/test-book/assets/js/30.72f82acf.js"><link rel="prefetch" href="/test-book/assets/js/31.6c8aaa12.js"><link rel="prefetch" href="/test-book/assets/js/32.8f1dcdbc.js"><link rel="prefetch" href="/test-book/assets/js/33.4017c4ea.js"><link rel="prefetch" href="/test-book/assets/js/34.e63ef5ea.js"><link rel="prefetch" href="/test-book/assets/js/35.b29ee815.js"><link rel="prefetch" href="/test-book/assets/js/4.36850638.js"><link rel="prefetch" href="/test-book/assets/js/5.042bebf2.js"><link rel="prefetch" href="/test-book/assets/js/6.f687cbd5.js"><link rel="prefetch" href="/test-book/assets/js/7.eea66bef.js"><link rel="prefetch" href="/test-book/assets/js/8.1076ef6a.js"><link rel="prefetch" href="/test-book/assets/js/9.ce0ca980.js">
    <link rel="stylesheet" href="/test-book/assets/css/0.styles.79946ec9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test-book/" class="home-link router-link-active"><!----> <span class="site-name">OpenCL Book</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/test-book/opencl-book/" class="nav-link router-link-active">
  OpenCL Book
</a></div><div class="nav-item"><a href="https://us.fixstars.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Fixstars Solutions
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/test-book/opencl-book/" class="nav-link router-link-active">
  OpenCL Book
</a></div><div class="nav-item"><a href="https://us.fixstars.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Fixstars Solutions
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/test-book/opencl-book/" aria-current="page" class="sidebar-link">Foreword</a></li><li><a href="/test-book/opencl-book/who-should-read-this-book.html" class="sidebar-link">Who Should Read this Book?</a></li><li><a href="/test-book/opencl-book/about-the-authors.html" class="sidebar-link">About the Authors</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Introduction to Parallelization</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test-book/opencl-book/introduction-to-parallelization/why-parallelization.html" class="sidebar-link">Why Parallelization</a></li><li><a href="/test-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html" class="sidebar-link">Parallel Computing Hardware</a></li><li><a href="/test-book/opencl-book/introduction-to-parallelization/parallel-computing-software.html" class="sidebar-link">Parallel Computing Software</a></li><li><a href="/test-book/opencl-book/introduction-to-parallelization/conclusion.html" class="sidebar-link">Conclusion</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test-book/opencl-book/opencl/what-is-opencl.html" class="sidebar-link">What is OpenCL?</a></li><li><a href="/test-book/opencl-book/opencl/historical-background.html" class="sidebar-link">Historical Background</a></li><li><a href="/test-book/opencl-book/opencl/an-overview-of-opencl.html" class="sidebar-link">An Overview of OpenCL</a></li><li><a href="/test-book/opencl-book/opencl/why-opencl.html" class="sidebar-link">Why OpenCL?</a></li><li><a href="/test-book/opencl-book/opencl/applicable-platforms.html" class="sidebar-link">Applicable Platforms</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>OpenCL Setup</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test-book/opencl-book/opencl-setup/available-opencl-environments.html" class="sidebar-link">Available OpenCL Environments</a></li><li><a href="/test-book/opencl-book/opencl-setup/development-environment-setup.html" class="sidebar-link">Development Environment Setup</a></li><li><a href="/test-book/opencl-book/opencl-setup/first-opencl-program.html" class="sidebar-link">First OpenCL Program</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Basic OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test-book/opencl-book/basic-opencl/basic-program-flow.html" class="sidebar-link">Basic Program Flow</a></li><li><a href="/test-book/opencl-book/basic-opencl/online-offline-compilation.html" class="sidebar-link">Online/Offline Compilation</a></li><li><a href="/test-book/opencl-book/basic-opencl/calling-the-kernel.html" class="sidebar-link">Calling the Kernel</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Advanced OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test-book/opencl-book/advanced-opencl/opencl-c.html" class="sidebar-link">OpenCL C</a></li><li><a href="/test-book/opencl-book/advanced-opencl/opencl-programming-practice.html" class="sidebar-link">OpenCL Programming Practice</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Changes made in OpenCL Specification 1.2</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.0-to-1.1.html" class="sidebar-link">Changes made in update from 1.0 to 1.1</a></li><li><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html" aria-current="page" class="active sidebar-link">Changes made in update from 1.1 to 1.2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html#changes-in-the-opencl-platform-layer-and-the-runtime" class="sidebar-link">Changes in the OpenCL Platform Layer and the Runtime</a></li><li class="sidebar-sub-header"><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html#changes-in-opencl-c" class="sidebar-link">Changes in OpenCL C</a></li><li class="sidebar-sub-header"><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html#deprecated-functions" class="sidebar-link">Deprecated functions</a></li><li class="sidebar-sub-header"><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html#using-sub-devices" class="sidebar-link">Using sub-devices</a></li><li class="sidebar-sub-header"><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html#sample-program-using-image-objects" class="sidebar-link">Sample Program using Image Objects</a></li><li class="sidebar-sub-header"><a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html#sample-program-using-migration" class="sidebar-link">Sample Program using Migration</a></li></ul></li></ul></section></li><li><a href="/test-book/opencl-book/references.html" class="sidebar-link">References</a></li><li><a href="/test-book/opencl-book/notes.html" class="sidebar-link">Notes</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="changes-made-in-update-from-1-1-to-1-2"><a href="#changes-made-in-update-from-1-1-to-1-2" class="header-anchor">#</a> Changes made in update from 1.1 to 1.2</h1> <h2 id="changes-in-the-opencl-platform-layer-and-the-runtime"><a href="#changes-in-the-opencl-platform-layer-and-the-runtime" class="header-anchor">#</a> <em>Changes in the OpenCL Platform Layer and the Runtime</em></h2> <p><strong>Custom Device</strong></p> <p>Some devices may have the OpenCL Runtime fully implemented, but do not support kernel-programming using OpenCL C. Such a device is categorized as a custom device. Non-programmable chips like ASIC, and DSPs that require specialized programming methods, are some examples of custom devices.</p> <p>Although OpenCL C may not be supported, a custom device may support an online compiler to generate machine codes to be executed on the device. Kernel program may be created from source using clCreateProgramWithSource() if an online compiler exists, from a binary, or from built-in kernels.</p> <p><strong>Built-in Kernel</strong></p> <p>A built-in kernel is a non-programmable kernel provided in the OpenCL implementation which utilizes fixed-function hardware or firmware. A list of built-in kernels can be queried from the application. Note that when creating an OpenCL program object, built-in kernels and OpenCL C kernels must be separate objects.</p> <p>A few changes were made to the runtime APIs to take into account for the addition of custom devices and built-in kernels described above.</p> <ul><li>The following can now be passed in as the 2nd argument to clGetDeviceInfo():</li></ul> <table><thead><tr><th>cl_device_info</th> <th>Return Type</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_DEVICE_BUILT_IN_KERNELS</td> <td>char[]</td> <td>Returns a semi-colon separated list of built-in kernels. An empty string is returned if the device does not support any built-in kernels.</td></tr> <tr><td>CL_DEVICE_LOCAL_MEM_TYPE</td> <td>cl_device, local_mem_type</td> <td><p>Returns the type of local memory supported. CL_NONE may be returned for custom devices with no local memory support. <br></p></td></tr></tbody></table> <ul><li>clCreateProgramWithBuiltInKernels</li></ul> <p>This function is used to create an OpenCL program object from built-in kernels.</p> <blockquote><p>cl_program clCreateProgramWithBuiltInKernels (</p> <p>cl_context context, // context object to associate with</p> <p>cl_uint num_devices, // number of elements in <em>device_list</em></p> <p>const cl_device_id *device_list, // list of devices</p> <p>const char *kernel_names, // kernel names to load</p> <p>cl_int *errcode_ret) // error code</p></blockquote> <p>Upon successful execution, a non-NULL program object will be returned, with errcode_ret set to CL_SUCCESS. If an error occurs, NULL will be returned, with errcode_ret set to the appropriate error code. The 4th parameter takes a semi-colon separated list of built-in kernels from which to create the program object from.\</p> <ul><li>The following can now be passed as the 3rd argument to clCreateProgramWithBuiltInKernels()</li></ul> <table><thead><tr><th>cl_kernel_work_group_info</th> <th>Return Type</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_KERNEL_GLOBAL_WORK_SIZE</td> <td>Size_t[3]</td> <td>Returns the maximum global size that can be used to execute a kernel.</td></tr></tbody></table> <p><strong>Device Partitioning</strong></p> <p>Starting with OpenCL 1.2, an OpenCL device may be partitioned into multiple sub-devices to be used independently of each other. The partitioning is performed in order of compute units. Any device being partitioned is called the parent device, and the original device from which the partitions are created is called the root device (<strong>Figure 7.1</strong>).</p> <p><strong>Figure7.1: Overview of device partitioning</strong></p> <p><img src="/test-book/assets/img/Screen_Shot_2022-01-12_at_11.07.44_PM.c7a72d0c.png" alt=""></p> <p>A sub-device is created using the following API.</p> <blockquote><p>cl_int clCreateSubDevices(cl_device_id in_device, // parent device</p> <p>const cl_device_partition_property *properties, // partition properties</p> <p>cl_uint num_devices, // number of elements in <em>out_devices</em></p> <p>cl_device_id *out_devices, // buffer to store returned sub-device IDs</p> <p>cl_uint *num_devices_ret) // number of sub-devices actually created</p></blockquote> <p>The properties passed in as the 2nd argument should have one of the 3 formats:</p> <blockquote><p>{CL_DEVICE_PARTITION_EQUALLY, uint numComputeUnits, 0}</p> <p>{CL_DEVICE_PARTITION_BY_COUNTS, uint numComputeUnitsA, uint numComputeUnitsB, ..., 0}</p> <p>{CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN, cl_device_affinity_domain, 0}</p></blockquote> <p>In all 3 cases, the last argument passed in must be 0. The description of the 1st argument passed in is as follows.</p> <table><thead><tr><th>Partition mode</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_DEVICE_PARTITION_EQUALLY</td> <td>Partition compute units such that each partition contains the number of compute units specified in the 2nd argument inside <em>properties</em></td></tr> <tr><td>CL_DEVICE_PARTITION_BY_COUNTS</td> <td>Partition compute units according to the numbers passed in as 2nd to 2nd to last argument inside properties</td></tr> <tr><td>CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN</td> <td><p>Split the device into smaller aggregate devices containing compute units that all share part of a cache hierarchy. The 2nd argument inside properties must be one of the following. </p><p>CL_DEVICE_AFFINITY_DOMAIN_NUMA: compute units CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN share a NUMA node </p><p>CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE: compute units share a level 4 data cache </p><p>CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE: compute units share a level 3 data cache </p><p>CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE: compute units share a level 2 data cache </p><p>CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE: compute units share a level 1 data cache </p><p>CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE: compute units share memory subsystem at the next partitionable affinity domain, with the order being NUMA, L4, L3, L2, L1. </p></td></tr></tbody></table> <p>For example, to split a device containing 16 compute units to sub-devices such that each sub-device contains 8 compute units, thereby creating 2 sub-devices with 8 compute units each, pass the following in <em>properties</em>:</p> <blockquote><p>{ CL_DEVICE_PARTITION_EQUALLY, 8, 0 }</p></blockquote> <p>To partition a device containing 4 compute units such that one sub-device contains 3 compute units and the other sub-device contains 1 compute units, pass the following in <em>properties</em>:</p> <blockquote><p>{ CL_DEVICE_PARTITION_BY_COUNTS, 3, 1,</p> <p>CL_DEVICE_PARTITION_BY_COUNTS_LIST_END, 0 }</p></blockquote> <p>To split a device along the outermost cache line, pass the following in <em>properties</em>:</p> <blockquote><p>{ CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN,</p> <p>CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE, 0 }</p></blockquote> <p><strong>cl_mem_flags</strong></p> <p>cl_mem_flags, which is set when creating buffer objects or image objects using clCreateBuffer, clCreateSubBuffer, or clCreateImage, now has the following additional flags that can be set.</p> <table><thead><tr><th>cl_mem_flags</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_MEM_HOST_WRITE_ONLY</td> <td>The host will only write to the memory object.</td></tr> <tr><td>CL_MEM_HOST_READ_ONLY</td> <td>The host will only read from the memory object.</td></tr> <tr><td>CL_MEM_HOST_NO_ACCESS</td> <td>The host will neither read from nor write to the memory object.</td></tr></tbody></table> <p>Note that CL_MEM_HOST_WRITE_ONLY and CL_MEM_HOST_READ_ONLY cannot be specified together. Also, if CL_MEM_HOST_NO_ACCESS is set, neither CL_MEM_HOST_WRITE_ONLY nor CL_MEM_HOST_READ_ONLY can also be set.</p> <p>If cl_mem_flags is set to 0, the default value will be CL_MEM_READ_WRITE. However, when creating an image object from a buffer object (which can be passed in as a parameter in cl_image_desc for clCreateImage), the flag will inherit that of the buffer instead (See 7.2.2).</p> <p><strong>cl_map_flag</strong></p> <p>Device memory in buffer objects and image objects can be mapped to the host-side memory using clEnqueueMapBuffer and clEnqueueMapImage. In OpenCL 1.2, the following cl_map_flag was added, which sets the property of the host-side memory.</p> <table><thead><tr><th>cl_map_flag</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_MAP_WRITE_INVALIDATE_REGION</td> <td>This flag specifies that the host-side memory is mapped only for writing. As such, any changes made to the host-side memory will not be reflected to the device-side memory.</td></tr></tbody></table> <p>Unlike in CL_MAP_WRITE supported in OpenCL 1.0/1.1, there is no guarantee that the pointer returned by clEnqueueMapBuffer and clEnqueueMapImage reflects the latest content of the memory object on the device, since the host can make changes to this memory region as much as it wants. This can be a performance enhancement, as it eliminates memory transfers from the host to the device every time a change is made.</p> <blockquote><p>CL_MAP_WRITE_INVALIDATE_REGION cannot be specified with CL_MAP_READ or CL_MAP_WRITE.</p></blockquote> <p><strong>Fill Buffer with pattern</strong></p> <p>OpenCL 1.2 added a new API to fill a buffer object on the device with a certain pattern.</p> <blockquote><p>cl_int clEnqueueFillBuffer(cl_command_queue command_queue,</p> <p>cl_mem buffer, // buffer to fill</p> <p>const void *pattern, // data pattern to fill with</p> <p>size_t pattern_size, // size of the data pattern</p> <p>size_t offset, // offset to start the filling from (in Bytes)</p> <p>size_t size, // number of bytes to fill</p> <p>cl_uint num_events_in_wait_list,</p> <p>const cl_event *event_wait_list,</p> <p>cl_event *event)</p></blockquote> <p>This function fills the buffer starting from offset for a number of bytes specified by size. Note that size must be an integer multiple of pattern_size.</p> <p>Similarly, the following function is used to fill an image object on the device with a certain pattern.</p> <blockquote><p>cl_int clEnqueueFilleImage(cl_command_queue command_queue,</p> <p>cl_mem image, // image object to fill</p> <p>const void *fill_color, // color to fill with</p> <p>const size_t *origin, // coordinates to start the fill</p> <p>const size_t *region, // area to fill</p> <p>cl_uint num_events_in_wait_list,</p> <p>const cl_event *event_wait_list,</p> <p>cl_event *event)</p></blockquote> <p>Note that fill_color corresponds to the channel data type of the image object.</p> <ul><li><p>signed RGBA if channel data is un-normalized, signed integer</p></li> <li><p>unsigned RGBA if channel data is un-normalize, unsigned integer</p></li> <li><p>float RGBA otherwise</p></li></ul> <p>The origin is a 3-element vector, each corresponding to x, y, z dimension, respectively. If image is a 2D image object, origin[2] should be 0. If image is 1D image or 1D image buffer object, both origin[1] and origin[2] should be 0. If image is a 1D image array object, origin[1] is the image index in the 1D image array. If image is a 2D image array object, origin[2] is the image index in the 2D image array. (See 7.2.2 for new image data formats)</p> <p>The region is similarly a 3-element vector, each corresponding to width, height, and depth. If image is a 2D image object or an 1D image array object, region[2] should be set to 1. If image is an 1D image object or an 1D image buffer object, both region[1] and region[2] should be set to 1.</p> <p><strong>clCreateImage()</strong></p> <p>Up until OpenCL 1.1, image objects were created with clCreateImage2D and clCreateImage3D. In OpenCL 1.2, those functions are now deprecated. Instead, more generic, clCreateImage will take its place. This function can be used also for the newly supported 1D image object, 1D image buffer object, and 2D image array object.</p> <blockquote><p>cl_mem clCreateImage(cl_context context,</p> <p>cl_mem_flags flags,</p> <p>const cl_image_format *image_format,</p> <p>const cl_image_desc *image_desc,</p> <p>void *host_ptr,</p> <p>cl_int *errcode_ret)</p></blockquote> <p>From now on, this function will be used to create image objects.</p> <p>context is the context for which to associate the image. flags is the same as the one used in clCreateBuffer to set read/write properties for the memory region. host_ptr points to the memory region to copy the image data from. This may be a memory region already associated with another object, but the data size of the accessed area must exceed that of the image object. errcode_ret is the error code returned.</p> <p>image_format is a structure with the following format.</p> <blockquote><p>typedef struct _cl_image_format {</p> <p>cl_channel_order image_channel_order;</p> <p>cl_channel_type image_channel_data_type;</p> <p>} cl_image_format;</p></blockquote> <p>image_channel_order specifies the number of channels, as well as the order of the channels (See <strong>Figure 5.6</strong>).</p> <p>image_channel_data_type specifies the data type of each channels (See <strong>Figure 5.6</strong>)</p> <p>image_desc is a structure with the following format.</p> <blockquote><p>typedef struct _cl_image_desc {</p> <p>cl_mem_object_type image_type,</p> <p>size_t image_width;</p> <p>size_t image_height;</p> <p>size_t image_depth;</p> <p>size_t image_array_size;</p> <p>size_t image_row_pitch;</p> <p>size_t image_slice_pitch;</p> <p>cl_uint num_mip_levels;</p> <p>cl_uint num_samples;</p> <p>cl_mem buffer;</p> <p>} cl_image_desc;</p></blockquote> <p>image_type is set to one of the following, whose description will be discussed in the next chapter.</p> <blockquote><p>CL_MEM_OBJECT_IMAGE1D</p> <p>CL_MEM_OBJECT_IMAGE1D_BUFFER</p> <p>CL_MEM_OBJECT_IMAGE1D_ARRAY</p> <p>CL_MEM_OBJECT_IMAGE2D</p> <p>CL_MEM_OBJECT_IMAGE2D_ARRAY</p> <p>CL_MEM_OBJECT_IMAGE3D</p></blockquote> <p>image_width is the number of pixels contained in the horizontal direction of the image. Its value must meet the following criteria.</p> <ul><li><p>2D image, 2D image array: image_width &lt; CL_DEVICE_IMAGE2D_MAX_WIDTH</p></li> <li><p>3D image: image_width &lt; CL_DEVICE_IMAGE3D_MAX_WIDTH</p></li> <li><p>1D image buffer: image_width &lt; CL_DEVICE_IMAGE_MAX_BUFFER_SIZE</p></li> <li><p>1D image, 1D image array: image_width &lt;= CL_DEVICE_IMAGE2D_MAX_WIDTH</p></li></ul> <p>\</p> <p>image_height is the number of pixels contained in the vertical direction of the image. This parameter is used only for 2D image, 3D image, and 2D image array. Its value must meet the following criteria.</p> <ul><li>2D image, 2D image array: image_height &lt;= CL_DEVICE_IMAGE_2D_MAX_HEIGHT</li></ul> <p>\</p> <ul><li>3D image: image_height &lt;= CL_DEVICE_IMAGE3D_MAX_HEIGHT</li></ul> <p>image_depth is the number of pixels in the image depth. This parameter is used only for a 3D image. Its value must meet the following criteria:</p> <ul><li>1 &lt;= image_depth &amp;&amp; image_depth &lt;= CL_DEVICE_IMAGE3D_MAX_DEPTH</li></ul> <p>\</p> <p>image_array_size is the number of images in the image array. This parameter is used for 1D image array and 2D image array. Its value must meet the following criteria.</p> <ul><li>1 &lt;= image_array_size &amp;&amp; image_array_size &lt;= CL_DEVICE_IMAGE_MAX_ARRAY_SIZE</li></ul> <p>\</p> <p>image_row_pitch is the scan-line pitch in bytes. This value should be 0 if host_ptr is NULL. If host_ptr is not NULL, this value should be set to 0 or pitch * size of elements in bytes. If 0 is set, the value is calculated automatically. The pitch must be greater than or equal to image_width.</p> <p>image_slice_pitch is the size in bytes of each 2D slice in the 3D image or the size in bytes of each image in a 1D or 2D image array. This must be set to 0 if host_ptr is NULL. If host_ptr is not NULL, this value should be set to either 0 or the appropriate value of the slice pitch. If 0 is set, the value is calculated automatically.</p> <p>num_mip_levels and num_samples must be set to 0.</p> <p>buffer is specified when creating a 1D image buffer object from an existing buffer object on the device. In all other cases, it must be NULL. The buffer size of the new image must be less than or equal to the buffer object from which to create the image.</p> <p><strong>Figure 7.2: Image object parameters</strong></p> <p><img src="/test-book/assets/img/Screen_Shot_2022-01-12_at_11.16.05_PM.686e6b27.png" alt=""></p> <p>By setting the parameters as described, clCreateImage allows creation of all types of images.</p> <p><strong>clEnqueueMigrateMemObjects</strong></p> <p>This function allows for migration of memory objects to a specific device.</p> <blockquote><p>cl_int clEnqueueMigrateMemObjects(</p> <p>cl_command_queue command_queue,</p> <p>cl_uint num_mem_objects,</p> <p>const cl_mem *mem_objects,</p> <p>cl_mem_migration_flags flags,</p> <p>cl_uint num_events_in_wait_list,</p> <p>const cl_evenet *event_wait_list,</p> <p>cl_event *event)</p></blockquote> <p>This provides a mechanism for explicit control over the location of memory object, which may be necessary in an environment with multiple devices for efficient access to memory. The flags can be specified the following values.</p> <table><thead><tr><th>cl_mem_migration_flags</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_MIGRATE_MEM_OBJECT_HOST</td> <td>Indicates that the memory objects are to be migrated to the host.</td></tr> <tr><td>CL_MIGRATE_MEM_OBJECT_CONTEN</td> <td>Indicates that the data within the object is not</td></tr> <tr><td>T_UNDEFINED</td> <td>transferred, minimizing the overhead of the migration.</td></tr></tbody></table> <p><strong>Separation of Compilation and Linking of Programs</strong></p> <p>Up until OpenCL 1.1, compilation and linking of programs could only be done together using clBuildProgram. Starting with OpenCL 1.2, this process can be done separately. In addition, the following can now be performed.</p> <ul><li><p>Embedded Header: Allows header sources to come from program objects instead of just head files, instead of having to include the search path of the header in the build option. \</p></li> <li><p>Libraries: The linker allows for linking of compiled objects and libraries into a program executable or library. \</p></li></ul> <p>The following function is used for compiling a program.</p> <blockquote><p>cl_int clCompileProgram(cl_program program,</p> <p>cl_uint num_devices,</p> <p>const char *options,</p> <p>cl_uint num_input_headers,</p> <p>const cl_program *input_headers,</p> <p>const char **header_include_names,</p> <p>void (CL_CALLBACK *pfn_notify)(cl_program program,</p> <p>void *user_data),</p> <p>void *user_data)</p></blockquote> <p>device_list is the list of devices for which to perform the compilation. This value can be set to NULL to compile the program for all devices associated with program.</p> <p>input_headers is a list of program embedded headers created with clCreateProgramWithSource. header_include_names should be set such that each string element corresponds to the name of the header files.</p> <p>An example usage is as follows. For instance, if the source-file of the kernel is as follows.</p> <blockquote><p>#include &lt;header1.h&gt;</p> <p>#include &lt;dir/header2.h&gt;</p> <p>__kernel void test_kernel (int n, int m)</p> <p>{</p> <p>...</p> <p>}</p></blockquote> <p>The program objects for the 2 include-files are created as follows.</p> <blockquote><p>cl_program header1_pg = clCreateProgramWithSource(context, 1, &amp;header1_src, NULL, &amp;err);</p> <p>cl_program header2_pg = clCreateProgramWithSource(context, 1, &amp;header2_src, NULL, &amp;err);</p></blockquote> <p>If no callback is set (pfn_notify is set to NULL), clCompileProgram will be a blocking call, and will not return until the compiling is finished.</p> <p>In order to link the compiled program objects to create a binary, the following function is used.</p> <blockquote><p>cl_program clLinkProgram(cl_context context,</p> <p>cl_uint num_devices,</p> <p>const cl_device_id *device_list,</p> <p>const char *options,</p> <p>cl_uint num_input_programs,</p> <p>const cl_program *input_programs,</p> <p>void (CL_CALLBACK *pfn_notify) (cl_program program,</p> <p>Void *user_data),</p> <p>void *user_data,</p> <p>cl_int *errcode_ret)</p></blockquote> <p>Similarly to clCompileProgram, device_list can be set to NULL, which will perform linking towards all devices associated with the context. If no callback is set (pfn_notify is set to NULL), clLinkProgram will be a blocking call, returning after linking is performed.</p> <p>For compile options and build options, refer to the function reference in Chapter 8.</p> <p><strong>clGetProgramInfo</strong></p> <p>This function is used to obtain information from a program object.</p> <p>cl_int clGetProgramInfo(cl_program program,</p> <p>cl_program_info param_name,</p> <p>size_t param_value_size,</p> <p>void *param_value,</p> <p>size_t *param_value_size_ret)</p> <p>In OpenCL 1.2, the following can be passed in additionally as the parameter name for the 2nd argument.</p> <table><thead><tr><th>cl_program_info_param_name</th> <th>Return Type</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_PROGRAM_NUM_KERNELS</td> <td>size_t</td> <td>Returns the number of kernels contained within the program object.</td></tr> <tr><td>CL_PROGRAM_KERNEL_NAMES</td> <td>char[]</td> <td>Returns the names of kernels contained within the program object.</td></tr></tbody></table> <p><strong>clGetProgramBuildInfo</strong></p> <p>This function can be used to obtain build information from a program object.</p> <blockquote><p>cl_int clGetProgramBuildInfo(cl_program program,</p> <p>cl_device_id device,</p> <p>cl_program_build_info param_name,</p> <p>size_t param_value_size,</p> <p>void *param_value,</p> <p>size_t *param_value_size_ret)</p></blockquote> <p>In OpenCL 1.2, the following can be passed in additionally as the parameter name for the 3rd argument.</p> <table><thead><tr><th>cl_program_build_info</th> <th>Return Type</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_PROGRAM_BINARY_TYPE</td> <td>cl_program_binary_type</td> <td><p>Returns one of the following. </p><p>CL_PROGRAM_BINARY_TYPE_NONE: No binary exist that is associated with the device. </p><p>CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT: The object is a compiled binary. </p><p>CL_PROGRAM_BINARY_TYPE_LIBRARY: The object is a library </p><p>CL_PROGRAM_BINARY_TYPE_EXECUTABLE: The object is executable </p></td></tr></tbody></table> <p><strong>clGetKernelArgInfo</strong></p> <p>This function can be used to obtain kernel argument information.</p> <blockquote><p>cl_int clGetKernelArgInfo(cl_kernel kernel,</p> <p>cl_uint arg_index,</p> <p>cl_kernel_arg_info param_name,</p> <p>size_t param_value_size,</p> <p>void *param_value,</p> <p>size_t *param_value_size_ret)</p></blockquote> <p>arg_index specifies the argument for which to retrieve information. This index corresponds to the arg_index specified in clSetKernelArg. The information that can be obtained is the following.</p> <table><thead><tr><th>param_name</th> <th>Return Type</th> <th>Description</th></tr></thead> <tbody><tr><td>CL_KERNEL_ARG_ADDRESS_QUALIFIER</td> <td>cl_kernel_arg_address_qualifier</td> <td><p>Returns the address qualifier. The following values can be returned: </p><p>CL_KERNEL_ARG_ADDRESS_GLOBAL </p><p>CL_KERNEL_ARG_ADDRESS_LOCAL </p><p>CL_KERNEL_ARG_ADDRESS_CONSTANT </p><p>CL_KERNEL_ARG_ADDRESS_PRIVATE </p><p>The default address qualifier is CL_KERNEL_ARG_ADDRESS_PRIVATE unless explicitly changed </p></td></tr> <tr><td>CL_KERNEL_ARG_ACCESS_QUALIFIER</td> <td>cl_kernel_arg_access_qualifier</td> <td><p>Returns the access qualifier. The following values can be returned. </p><p>CL_KERNEL_ARG_ACCESS_READ_ONLY </p><p>CL_KERNEL_ARG_ACCESS_WRITE_ONLY </p><p>CL_KERNEL_ARG_ACCESS_READ_WRITE </p><p>CL_KERNEL_ARG_ACCESS_NONE </p><p>If the specified argument is not an image buffer, CL_KERNEL_ARG_ACCESS_NONE will be returned </p></td></tr> <tr><td>CL_KERNEL_ARG_TYPE_NAME</td> <td>char[]</td> <td>Returns the data type of the argument</td></tr> <tr><td>CL_KERNEL_ARG_TYPE_QUALIFIER</td> <td>cl_kernel_arg_type_qualifier</td> <td><p>Returns the type qualifier of the argument. The returned type will be a combination of the following. </p><p>CL_KERNEL_ARG_TYPE_CONST </p><p>CL_KERNEL_ARG_TYPE_RESTRICT </p><p>CL_KERNEL_ARG_TYPE_VOLATILE </p><p>If no type qualifier is present, CL_KERNEL_ARG_TYPE_NONE will be returned </p></td></tr> <tr><td>CL_KERNEL_ARG_NAME</td> <td>char[]</td> <td>Returns the name of the argument</td></tr></tbody></table> <p>The only way CL_KERNEL_ARG_TYPE_VOLATILE can be returned is when the type qualifier volatile is specified in the argument, and the argument is a pointer. For example, if the kernel argument is int volatile *x, CL_KERNEL_ARG_TYPE_VOLATILE will be returned, but if the argument is int * volatile x, CL_KERNEL_ARG_TYPE_NONE is returned.</p> <p><strong>Controlling Events</strong></p> <p>Up until OpenCL 1.1, barrier synchronization of commands and execution order control using events were performed using clEnqueueMarker, clEnqueueBarrier, and clEnqueueWaitForEvents. In OpenCL 1.2, these APIs are deprecated, being replaced with clEnqueueMarkerWithWaitList and clEnqueueBarrierWithWaitList.</p> <p>The marker command can be used to wait for a set of events in the command queue to complete.</p> <blockquote><p>cl_int clEnqueueMarkerWithWaitList(</p> <p>cl_command_queue command_queue,</p> <p>cl_uint num_events_in_wait_list,</p> <p>const cl_event *event_wait_list,</p> <p>cl_event *event)</p></blockquote> <p>This command returns an event, whose status can be used to wait until the set of events are complete. event_wait_list can be set to NULL, in which case the event marker will wait until all previously enqueued commands in the command queue have finished its execution.</p> <p>To enqueue a barrier command to a command queue, the following API is used.</p> <blockquote><p>cl_int clEnqueueBarrierWithWaitList(</p> <p>cl_command_queue command_queue,</p> <p>cl_uint num_events_in_wait_list,</p> <p>const cl_event *event_wait_list,</p> <p>cl_event *event)</p></blockquote> <p>The difference between this and clEnqueueMarkerWithWaitLIist is that this function blocks until the events of interest have all finished. event_wait_list can similarly be set to NULL, in which case the function blocks until all previously enqueued commands in the command queue have finished its execution.</p> <h2 id="changes-in-opencl-c"><a href="#changes-in-opencl-c" class="header-anchor">#</a> <em>Changes in OpenCL C</em></h2> <p><strong>New image data types</strong></p> <p>Up until OpenCL 1.1, the available built-in data types for images were image2d_t for 2D image object, and image3d_t for 3D image object. OpenCL 1.2 introduced the following new image data types.</p> <ul><li><p>image1d_t: 1D image data</p></li> <li><p>image1d_buffer_t: image data created from buffer object</p></li> <li><p>image1d_array: array of 1D image data</p></li> <li><p>image2d_array_t: array of 2D image data</p></li></ul> <p>image1d_buffer_t will be discussed here, as the other 3 data types are self-explanatory. This is an image object whose 1D data is contained in a separate OpenCL buffer object. The association is made during clCreateImage, when cl_image_desc is passed in as a parameter, with the buffer parameter set to that of the OpenCL buffer object. The memory access qualifiers are inherited from buffer and thus ignored when specified in cl_mem_flags, with the exception of CL_MEM_READ_WRITE, CL_MEM_READ_ONLY, and CL_MEM_WRITE_ONLY, which are inherited only when none of the 3 flags are set.</p> <p>The image data types are used only as a parameter to kernel functions, since it is a pointer to the object, and not a pointer to the actual data. To access the data itself requires the use of built-in functions. Similarly to the previous sections, the addition of image data types required changes to be made to OpenCL runtime functions (mainly clCreateImage) and built-in functions (read_image{f|i|ui}, write_image{f|i|ui}, get_image_width, get_image_height, get_image_channel_data_type).</p> <p><strong>New built-in functions</strong></p> <p>The following new built-in functions were introduced in OpenCL 1.2.</p> <ul><li>gentype popcount(gentype x)</li></ul> <p>Returns the number of non-zero bits in x. The gentype here corresponds to char, char{2|3|4|8|16}, uchar, uchar{2,3,4,8,16}, short, short{2,3,4,8,16}, ushort, ushort{2|3|4|8|16}, int, int{2|3|4|8|16}, int, int{2|3|4|8|16}, uint, uint{2|3|4|8|16}, long, long|2|3|4|8|16}, ulong, ulong{2|3|4|8|16}.</p> <ul><li><p>int printf(constant char *restrict format, ...)</p></li> <li><p>Performs the same operation as the printf in C (C99), with the following differences.</p></li> <li><p>The length modifier <strong>l</strong> is not supported for format placeholders <strong>c</strong> and <strong>s</strong></p></li> <li><p>Length modifier ll, j, z, t, L are reserved, but not supported</p></li> <li><p>Conversion specifier <strong>n</strong> is reserved, but not supported</p></li> <li><p>Vector specifier <strong>vn</strong> is supported for the printing of vector types</p></li> <li><p>A float argument is converted to double for conversion specifiers <strong>f</strong>, <strong>F</strong>, <strong>e</strong>, <strong>E</strong>, <strong>g</strong>, <strong>G</strong>, <strong>a</strong>, <strong>A</strong> only when the double data type is supported.</p></li> <li><p>For the embedded profile, the length modifier <strong>l</strong> is supported only when 64-bit integers are supported</p></li> <li><p>Returns 0 is success, and -1 when error occurs during a call to printf</p></li> <li><p>The conversion specifier <strong>s</strong> can be used only for arguments that are literal strings</p></li></ul> <p><strong>Changes in Extensions</strong></p> <p>The double data type that was an extensions in OpenCL 1.1 have become a core feature in OpenCL 1.2. This has required changes to many OpenCL runtime functions and built-in functions, mainly for arguments and return values.</p> <p><strong>Storage class specifiers</strong></p> <p>The typedef, extern, and static storage-class specifiers are supported from OpenCL 1.2. The auto and register remains unsupported.</p> <p>The extern storage-class specifier can be used only for functions and global variables declared in program scope, or variables declared inside a function. The function can be either kernel or non-kernel functions. The static storage-class specifier can be used only for non-kernel functions and global variables declared in program scope.</p> <p><strong>MACROS</strong></p> <p>The __OPENCL_C_VERSION__ was added, which corresponds to the OpenCL C version specified in clBuildProgram and clCompileProgram, with -cl-std. If no OpenCL C version is specified using -cl-std, the OpenCL C version supported by the compiler for the device will be used.</p> <h2 id="deprecated-functions"><a href="#deprecated-functions" class="header-anchor">#</a> <em>Deprecated functions</em></h2> <p>In addition to what has already been discussed in the previous sections, the following functions have become deprecated.</p> <ul><li><p>clUnloadCompiler, clGetExtensionFunctionAddress</p></li> <li><p>clCreateFromGLTexture2D, clCreateFromGLTexture3D</p></li> <li><p>CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE enum to be passed into clGetDeviceInfo</p></li></ul> <p><strong>Sample Program using the new features</strong></p> <p>The previous sections discussed the changes made to the OpenCL specification from 1.0 to 1.2. A sample program will be written in this section, which utilizes the new features of OpenCL. Note, however, that as of this writing, no environment exists which fully passes the OpenCL 1.2 conformance test16. AMD Accelerated Parallel Processing (APP) SDK, however has a preview-supported version of OpenCL 1.2, which implements most of the new features. This implementation was used to test the sample programs from this section. The tested environment is as follows.</p> <table><thead><tr><th>Environment</th> <th>Version</th></tr></thead> <tbody><tr><td>CPU</td> <td>Phenom II X6 T1100 3.3 GHz</td></tr> <tr><td>GPU</td> <td>Radeon 6970</td></tr> <tr><td>OS</td> <td>Windows 7 64bit</td></tr> <tr><td>Driver</td> <td>Version 8.95</td></tr> <tr><td>CL Runtime</td> <td>OpenCL 1.1 AMD-APP.internal.opt (891)17</td></tr> <tr><td>CAL</td> <td>Version 1.4.169</td></tr></tbody></table> <h2 id="using-sub-devices"><a href="#using-sub-devices" class="header-anchor">#</a> <em>Using sub-devices</em></h2> <p>In this example, the new sub-device feature will be used, which will device a CPU device into 2 sub-devices, and execute the same kernel in both devices, changing the argument passed in. Since each device maintains an independent command queue, the 2 tasks can be performed in parallel.</p> <p><strong>List 7.1: Sample program using sub-devices</strong></p> <blockquote><p>#include &lt;cassert&gt;</p> <p>#include &lt;cstring&gt;</p> <p>#include &lt;iostream&gt;</p> <p>#include &lt;CL/cl.h&gt;</p> <p>#define USING_SUB_DEVICE</p> <p>int main(int argc, char *argv[])</p> <p>{</p> <p>cl_int ret;</p> <p>/* get platform ID */</p> <p>cl_uint num_platform;</p> <p>cl_platform_id platform_id;</p> <p>ret = clGetPlatformIDs(1, &amp;platform_id, &amp;num_platform);</p> <p>assert(CL_SUCCESS == ret);</p> <p>#if defined USING_SUB_DEVICE</p> <p>/* get device IDs */</p> <p>cl_uint num_device;</p> <p>cl_device_id device_id;</p> <p>ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_CPU, 1, &amp;device_id, &amp;num_device);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* get number of compute unit */</p> <p>cl_uint num_cu;</p> <p>ret = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &amp;num_cu, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* partition devices */</p> <p>cl_device_id device_ids[2];ret = clCreateSubDevices(device_id, props, 2, device_ids, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>#else</p> <p>/* get device IDs */</p> <p>cl_uint num_device;</p> <p>cl_device_id device_ids[2];</p> <p>ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 2, device_ids, &amp;num_device);</p> <p>assert(CL_SUCCESS == ret);</p> <p>#endif</p> <p>/* create context and command queue */</p> <p>cl_context context;</p> <p>cl_command_queue command_queues[2];</p> <p>context = clCreateContext(NULL, 2, device_ids, NULL, NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>command_queues[i] = clCreateCommandQueue(context, device_ids[i], 0, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>/* build kernel */</p> <p>const char *source =</p> <p>&quot;#pragma OPENCL EXTENSION cl_amd_printf : enable¥n&quot;</p> <p>&quot;__kernel¥n&quot;</p> <p>&quot;void my_kernel(int i)¥n&quot;</p> <p>&quot;{¥n&quot;</p> <p>&quot;printf(¥&quot;I am device %d.¥¥n¥&quot;, i);¥n&quot;</p> <p>&quot;}¥n&quot;;</p> <p>size_t source_len = strlen(source);</p> <p>cl_program program = clCreateProgramWithSource(context, 1, &amp;source, &amp;source_len, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>ret = clBuildProgram(program, 2, device_ids, NULL, NULL, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>cl_kernel kernel = clCreateKernel(program, &quot;my_kernel&quot;, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* execute */</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>clSetKernelArg(kernel, 0, sizeof(cl_int), &amp;i);</p> <p>assert(CL_SUCCESS == ret);</p> <p>clEnqueueTask(command_queues[i], kernel, 0, NULL, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>clFinish(command_queues[i]);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>/* finalizing */</p> <p>clReleaseKernel(kernel);</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>clReleaseCommandQueue(command_queues[i]);</p> <p>}</p> <p>clReleaseContext(context);</p> <p>return 0;</p> <p>}</p></blockquote> <p>We will now walk you through the important lines in the program. CL_DEVICE_TYPE_CPU is specified in clGetDeviceIDs to obtain a list of CPUs that can be used as a device.</p> <blockquote><p>cl_uint num_device;</p> <p>cl_device_id device_id;</p> <p>ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_CPU, 1, &amp;device_id, &amp;num_device);</p></blockquote> <p>Next, we look at the number of compute units on the device.</p> <blockquote><p>cl_uint num_cu;</p> <p>ret = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &amp;num_cu, NULL);</p></blockquote> <p>The value obtained will be used as a basis to partition the CPU device into sub-devices. We will create the sub-devices so that the sub-devices will use the same number of compute units. This is done by specifying CL_DEVICE_PARTITION_EQUALLY.</p> <blockquote><p>cl_device_id device_ids[2];</p> <p>const cl_device_partition_property props[] = {CL_DEVICE_PARTITION_EQUALLY, num_cu/2, 0};</p> <p>ret = clCreateSubDevices(device_id, props, 2, device_ids, NULL);</p></blockquote> <p>The rest of the code in the program is written in the same manner as that for programming multiple devices. A context is created, from which a command queue is created for each sub-device, and then each command queue is executed.</p> <p>Execution of the sample program should result in the following.</p> <blockquote><p>$ ./subdevice</p> <p>I am device 0.</p> <p>I am device 1.</p></blockquote> <h2 id="sample-program-using-image-objects"><a href="#sample-program-using-image-objects" class="header-anchor">#</a> <em>Sample Program using Image Objects</em></h2> <p>In this section, the image objects will be created using clCreateImage, which is the new API introduced in OpenCL 1.2 for creating image objects. The image object will then be filled using clEnqueueFillImage.</p> <p><strong>List 7.2 Sample Program using Image Objects</strong></p> <blockquote><p>#include &lt;cassert&gt;</p> <p>#include &lt;cstring&gt;</p> <p>#include &lt;iomanip&gt;</p> <p>#include &lt;iostream&gt;</p> <p>#include &lt;vector&gt;</p> <p>#include &lt;malloc.h&gt;</p> <p>#include &lt;CL/cl.h&gt;</p> <p>#ifdef _MSC_VER</p> <p>#define ALIGNED_MALLOC(size, alignment) _aligned_malloc(size, alignment)</p> <p>#define ALIGNED_FREE(ptr) _aligned_free(ptr)</p> <p>#elif __GNUC__</p> <p>#define ALIGNED_MALLOC(size, alignment) memalign(alignment, size)</p> <p>#define ALIGNED_FREE(ptr) free(ptr)</p> <p>#else</p> <p>#error &quot;unsupported compiler&quot;</p> <p>#endif</p> <p>#define IMAGE_W (8)</p> <p>#define IMAGE_H (8)</p> <p>int main(int argc, char *argv[])</p> <p>{</p> <p>cl_int ret;</p> <p>/* get platform ID */</p> <p>cl_platform_id platform_id;</p> <p>ret = clGetPlatformIDs(1, &amp;platform_id, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* get device IDs */</p> <p>cl_device_id device_id;</p> <p>ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 1, &amp;device_id, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* create context */</p> <p>cl_context context = clCreateContext(NULL, 1, &amp;device_id, NULL, NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* create command queue */</p> <p>cl_command_queue command_queue = clCreateCommandQueue(context, device_id, 0, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* create image object */</p> <p>cl_image_format format;</p> <p>format.image_channel_order = CL_R;</p> <p>format.image_channel_data_type = CL_UNSIGNED_INT8;</p> <p>cl_image_desc desc;</p> <p>memset(&amp;desc, 0, sizeof(desc));</p> <p>desc.image_type = CL_MEM_OBJECT_IMAGE2D;</p> <p>desc.image_width = IMAGE_W;</p> <p>desc.image_height = IMAGE_H;</p> <p>cl_mem image = clCreateImage(context, 0, &amp;format, &amp;desc, NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* filling background image */</p> <p>{</p> <p>const size_t origin[] = {0, 0, 0};</p> <p>const size_t region[] = {IMAGE_W, IMAGE_H, 1};</p> <p>cl_uchar4 fill_color;</p> <p>fill_color.s[0] = 0;</p> <p>fill_color.s[1] = 0;</p> <p>fill_color.s[2] = 0;</p> <p>fill_color.s[3] = 0;</p> <p>ret = clEnqueueFillImage(command_queue, image, &amp;fill_color, origin, region, 0, NULL, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>/* filling front image */</p> <p>{</p> <p>const size_t origin[] = {(IMAGE_W*1)/4, (IMAGE_H*1)/4, 0};</p> <p>const size_t region[] = {(IMAGE_W*2)/4, (IMAGE_H*2)/4, 1};</p> <p>cl_uchar4 fill_color;</p> <p>fill_color.s[0] = 255;</p> <p>fill_color.s[1] = 0;</p> <p>fill_color.s[2] = 0;</p> <p>fill_color.s[3] = 0;</p> <p>ret = clEnqueueFillImage(command_queue, image, &amp;fill_color, origin, region, 0, NULL, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>/* reading image */</p> <p>cl_uchar *data = NULL;</p> <p>{</p> <p>size_t num_channels = 1;</p> <p>data = static_cast&lt;cl_uchar*&gt;(ALIGNED_MALLOC(IMAGE_W*IMAGE_H*sizeof(cl_uchar), num_channels*sizeof(cl_uchar)));</p> <p>assert(NULL != data);</p> <p>std::fill(&amp;data[0], &amp;data[IMAGE_W*IMAGE_H], 128);</p> <p>const size_t origin[] = {0, 0, 0};</p> <p>const size_t region[] = {IMAGE_W, IMAGE_H, 1};</p> <p>ret = clEnqueueReadImage(command_queue, image, CL_TRUE, origin, region, IMAGE_W*sizeof(cl_uchar), 0, data, 0, NULL, NULL);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>/* print image */</p> <p>for (unsigned int h=0; h&lt;IMAGE_H; ++h)</p> <p>{</p> <p>for (unsigned int w=0; w&lt;IMAGE_W; ++w)</p> <p>{</p> <p>std::cout &lt;&lt; std::setw(5) &lt;&lt; std::right &lt;&lt; static_cast&lt;int&gt;(data[h*IMAGE_W+w]);</p> <p>}</p> <p>std::cout &lt;&lt; std::endl;</p> <p>}</p> <p>/* finalizing */</p> <p>ALIGNED_FREE(data);</p> <p>clReleaseMemObject(image);</p> <p>clReleaseCommandQueue(command_queue);</p> <p>clReleaseContext(context);</p> <p>return 0;</p> <p>}</p></blockquote> <p>The structure of the program is as follows.</p> <p><strong>1. Create an image object with clCreateImage</strong></p> <p><strong>2. Fill the entire image with zeros using clEnqueueFillImage</strong></p> <p><strong>3. Fill over the center of the image with a different color</strong></p> <p><strong>4. Transfer the image to the host memory, and output the value of each pixels</strong></p> <p>In clCreateImage, the image parameters are grouped into the struct cl_image_format and cl_image_desc. The code is shown below.</p> <blockquote><p>cl_image_format format;</p> <p>format.image_channel_order = CL_R;</p> <p>format.image_channel_data_type = CL_UNSIGNED_INT8;</p> <p>cl_image_desc desc;</p> <p>memset(&amp;desc, 0, sizeof(desc));</p> <p>desc.image_type = CL_MEM_OBJECT_IMAGE2D;</p> <p>desc.image_width = IMAGE_W;</p> <p>desc.image_height = IMAGE_H;</p> <p>cl_mem image = clCreateImage(context, 0, &amp;format, &amp;desc, NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p></blockquote> <p>cl_image_format specifies the pixel format, and cl_image_desc describes the format of the image.</p> <p>In this program, the cl_image_format is set such that each pixel has 1-channel, with each element being an 8-bit unsigned integer. cl_image_desc is set such that the image is a 2D image, with dimensions IMAGE_W x IMAGE_H. If the device does not support the image format, clCreateImage will return with CL_IMAGE_FORMAT_NOT_SUPPORTED.</p> <p>Once the image object is created, the entire region is filled with zeros.</p> <blockquote><p>const size_t origin[] = {0, 0, 0};</p> <p>const size_t region[] = {IMAGE_W, IMAGE_H, 1};</p> <p>cl_uchar4 fill_color;</p> <p>fill_color.s[0] = 0;</p> <p>fill_color.s[1] = 0;</p> <p>fill_color.s[2] = 0;</p> <p>fill_color.s[3] = 0;</p> <p>ret = clEnqueueFillImage(command_queue, image, &amp;fill_color, origin, region, 0, NULL, NULL);</p></blockquote> <p>The color to fill with is specified by fill_color. Note that this color must const of 4 elements regardless of how many channels the image will have. The buffer will be filled only with fill_color.s[0], since CL_R was specified in cl_image_format. origin and region sets the range of pixels to fill, which in this case is the entire image. origin is a 3-element vector, which contains the {x,y,z} coordinate of the image, and region is a 3-element vector, with each element specifying the number of pixels to fill in each direction.</p> <p>In the next clEnqueueFillImage, the fill range as well as the color has been changed.</p> <blockquote><p>const size_t origin[] = {(IMAGE_W*1)/4, (IMAGE_H*1)/4, 0};</p> <p>const size_t region[] = {(IMAGE_W*2)/4, (IMAGE_H*2)/4, 1};</p> <p>cl_uchar4 fill_color;</p> <p>fill_color.s[0] = 255;</p> <p>fill_color.s[1] = 0;</p> <p>fill_color.s[2] = 0;</p> <p>fill_color.s[3] = 0;</p> <p>ret = clEnqueueFillImage(command_queue, image, &amp;fill_color, origin, region, 0, NULL, NULL);</p></blockquote> <p>Since CL_R will only look at the element in index 0, the value that concerns us is 255, which is the largest number that can be represented in 8 bits. Thus, the resulting image will be a white square in the middle, in front of a black background. Execution of this sample program should result in the following.</p> <blockquote><p>$ ./image</p> <p>0 0 0 0 0 0 0 0</p> <p>0 0 0 0 0 0 0 0</p> <p>0 0 255 255 255 255 0 0</p> <p>0 0 255 255 255 255 0 0</p> <p>0 0 255 255 255 255 0 0</p> <p>0 0 255 255 255 255 0 0</p> <p>0 0 0 0 0 0 0 0</p> <p>0 0 0 0 0 0 0 0</p></blockquote> <h2 id="sample-program-using-migration"><a href="#sample-program-using-migration" class="header-anchor">#</a> <em>Sample Program using Migration</em></h2> <p>Up until OpenCL 1.1, there was no way to explicitly specify where the actual data in the memory object existed. In some implementations, there was a possibility that the memory allocation or memory transfer could take place only when the data was actually used. OpenCL 1.2 introduced a mechanism for explicitly specifying which memory is to be used.</p> <p>The following sample program uses clEnqueueMigrateMemObjects to explicitly specify the location  of the memory object.</p> <p><strong>List 7.3 Sample Program using Migration</strong></p> <blockquote><p>#include &lt;cassert&gt;</p> <p>#include &lt;iostream&gt;</p> <p>#include &lt;CL/cl.h&gt;</p> <p>int main(int argc, char *argv[])</p> <p>{</p> <p>cl_int ret;</p> <p>/* get platform ID */</p> <p>cl_uint num_platform;</p> <p>cl_platform_id platform_id;</p> <p>ret = clGetPlatformIDs(1, &amp;platform_id, &amp;num_platform);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* get device IDs */</p> <p>cl_uint num_device;</p> <p>cl_device_id device_ids[2];</p> <p>ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 2, device_ids, &amp;num_device);</p> <p>assert(CL_SUCCESS == ret);</p> <p>/* create context and command queue */</p> <p>cl_context context;</p> <p>cl_command_queue command_queues[2];</p> <p>context = clCreateContext(NULL, 2, &amp;device_ids[0], NULL, NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>command_queues[i] = clCreateCommandQueue(context, device_ids[i], 0, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>}</p> <p>cl_mem mem1 = clCreateBuffer(context, CL_MEM_READ_WRITE, 128*sizeof(cl_float4), NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>ret = clEnqueueMigrateMemObjects( command_queues[0], 1, &amp;mem1, CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED, 0, 0, 0 );</p> <p>assert(CL_SUCCESS == ret);</p> <p>cl_mem mem2 = clCreateBuffer(context, CL_MEM_READ_WRITE, 128*sizeof(cl_float4), NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>ret = clEnqueueMigrateMemObjects( command_queues[1], 1, &amp;mem2, CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED, 0, 0, 0 );</p> <p>assert(CL_SUCCESS == ret);</p> <p>clReleaseMemObject(mem1);</p> <p>clReleaseMemObject(mem2);</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>clReleaseCommandQueue(command_queues[i]);</p> <p>}</p> <p>clReleaseContext(context);</p> <p>return 0;</p> <p>}</p></blockquote> <p>This program first creates 2 command queues within 1 OpenCL context.</p> <blockquote><p>cl_uint num_device;</p> <p>cl_device_id device_ids[2];</p> <p>ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_ALL, 2, device_ids, &amp;num_device);</p> <p>assert(CL_SUCCESS == ret);</p> <p>cl_context context;</p> <p>cl_command_queue command_queues[2];</p> <p>context = clCreateContext(NULL, 2, &amp;device_ids[0], NULL, NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>for (unsigned int i=0; i&lt;2; ++i)</p> <p>{</p> <p>command_queues[i] = clCreateCommandQueue(context, device_ids[i], 0, &amp;ret);</p></blockquote> <p>A memory object is then created, associating it with a specific device.</p> <blockquote><p>cl_mem mem1 = clCreateBuffer(context, CL_MEM_READ_WRITE, 128*sizeof(cl_float4), NULL, &amp;ret);</p> <p>assert(CL_SUCCESS == ret);</p> <p>ret = clEnqueueMigrateMemObjects( command_queues[0], 1, &amp;mem1, CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED, 0, 0, 0 );</p> <p>assert(CL_SUCCESS == ret);</p></blockquote> <p>The CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED specified as the 4th argument implies that no memory transfer of the data will take place during the call. Since no data is placed inside mem1 when clCreateBuffer was called, there would be no point in making sure that the new location of cl_mem contains the same information as the original.</p> <p>Now the device associated with command_queues[0] should have allocated 128*sizeof(cl_float4) bytes for the memory object. Any access to the memory object after this, which includes specifying the memory object during kernel calls, clEnqueueReadBuffer and clEnqueueWriteBuffer, is guaranteed to not require overheads due to memory allocation.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.0-to-1.1.html" class="prev">
        Changes made in update from 1.0 to 1.1
      </a></span> <span class="next"><a href="/test-book/opencl-book/references.html">
        References
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test-book/assets/js/app.b513c2d8.js" defer></script><script src="/test-book/assets/js/2.8dbd29eb.js" defer></script><script src="/test-book/assets/js/16.e7b0bbcf.js" defer></script>
  </body>
</html>
