<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Online/Offline Compilation | OpenCL Book</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#2492f3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/opencl-book/assets/css/0.styles.ecae2773.css" as="style"><link rel="preload" href="/opencl-book/assets/js/app.044fec5c.js" as="script"><link rel="preload" href="/opencl-book/assets/js/2.e23f9d0e.js" as="script"><link rel="preload" href="/opencl-book/assets/js/15.a1675395.js" as="script"><link rel="prefetch" href="/opencl-book/assets/js/10.1dcb20e9.js"><link rel="prefetch" href="/opencl-book/assets/js/11.c0ed33a0.js"><link rel="prefetch" href="/opencl-book/assets/js/12.7e83236b.js"><link rel="prefetch" href="/opencl-book/assets/js/13.5fb1d917.js"><link rel="prefetch" href="/opencl-book/assets/js/14.90f24845.js"><link rel="prefetch" href="/opencl-book/assets/js/16.e7b0bbcf.js"><link rel="prefetch" href="/opencl-book/assets/js/17.d9e4840b.js"><link rel="prefetch" href="/opencl-book/assets/js/18.2a111031.js"><link rel="prefetch" href="/opencl-book/assets/js/19.6f2b05fe.js"><link rel="prefetch" href="/opencl-book/assets/js/20.dca105f5.js"><link rel="prefetch" href="/opencl-book/assets/js/21.fffc28c0.js"><link rel="prefetch" href="/opencl-book/assets/js/22.b98ab071.js"><link rel="prefetch" href="/opencl-book/assets/js/23.6529153b.js"><link rel="prefetch" href="/opencl-book/assets/js/24.972fe0d7.js"><link rel="prefetch" href="/opencl-book/assets/js/25.ba81720e.js"><link rel="prefetch" href="/opencl-book/assets/js/26.ca0310e3.js"><link rel="prefetch" href="/opencl-book/assets/js/27.8a49061d.js"><link rel="prefetch" href="/opencl-book/assets/js/28.ad339dbd.js"><link rel="prefetch" href="/opencl-book/assets/js/29.b5e81878.js"><link rel="prefetch" href="/opencl-book/assets/js/3.d9fe953e.js"><link rel="prefetch" href="/opencl-book/assets/js/30.72f82acf.js"><link rel="prefetch" href="/opencl-book/assets/js/31.6cfd2144.js"><link rel="prefetch" href="/opencl-book/assets/js/32.a66512ff.js"><link rel="prefetch" href="/opencl-book/assets/js/33.4017c4ea.js"><link rel="prefetch" href="/opencl-book/assets/js/34.e63ef5ea.js"><link rel="prefetch" href="/opencl-book/assets/js/35.b29ee815.js"><link rel="prefetch" href="/opencl-book/assets/js/4.36850638.js"><link rel="prefetch" href="/opencl-book/assets/js/5.778824b7.js"><link rel="prefetch" href="/opencl-book/assets/js/6.3d4589fb.js"><link rel="prefetch" href="/opencl-book/assets/js/7.61d32e36.js"><link rel="prefetch" href="/opencl-book/assets/js/8.1076ef6a.js"><link rel="prefetch" href="/opencl-book/assets/js/9.a664e9a1.js">
    <link rel="stylesheet" href="/opencl-book/assets/css/0.styles.ecae2773.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/opencl-book/" class="home-link router-link-active"><!----> <span class="site-name">OpenCL Book</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/opencl-book/opencl-book/" class="nav-link router-link-active">
  OpenCL Book
</a></div><div class="nav-item"><a href="https://us.fixstars.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Fixstars Solutions
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/opencl-book/opencl-book/" class="nav-link router-link-active">
  OpenCL Book
</a></div><div class="nav-item"><a href="https://us.fixstars.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Fixstars Solutions
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/opencl-book/opencl-book/" aria-current="page" class="sidebar-link">Foreword</a></li><li><a href="/opencl-book/opencl-book/who-should-read-this-book.html" class="sidebar-link">Who Should Read this Book?</a></li><li><a href="/opencl-book/opencl-book/about-the-authors.html" class="sidebar-link">About the Authors</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Introduction to Parallelization</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/why-parallelization.html" class="sidebar-link">Why Parallelization</a></li><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-hardware.html" class="sidebar-link">Parallel Computing Hardware</a></li><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/parallel-computing-software.html" class="sidebar-link">Parallel Computing Software</a></li><li><a href="/opencl-book/opencl-book/introduction-to-parallelization/conclusion.html" class="sidebar-link">Conclusion</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/opencl/what-is-opencl.html" class="sidebar-link">What is OpenCL?</a></li><li><a href="/opencl-book/opencl-book/opencl/historical-background.html" class="sidebar-link">Historical Background</a></li><li><a href="/opencl-book/opencl-book/opencl/an-overview-of-opencl.html" class="sidebar-link">An Overview of OpenCL</a></li><li><a href="/opencl-book/opencl-book/opencl/why-opencl.html" class="sidebar-link">Why OpenCL?</a></li><li><a href="/opencl-book/opencl-book/opencl/applicable-platforms.html" class="sidebar-link">Applicable Platforms</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>OpenCL Setup</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/opencl-setup/available-opencl-environments.html" class="sidebar-link">Available OpenCL Environments</a></li><li><a href="/opencl-book/opencl-book/opencl-setup/development-environment-setup.html" class="sidebar-link">Development Environment Setup</a></li><li><a href="/opencl-book/opencl-book/opencl-setup/first-opencl-program.html" class="sidebar-link">First OpenCL Program</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Basic OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/basic-opencl/basic-program-flow.html" class="sidebar-link">Basic Program Flow</a></li><li><a href="/opencl-book/opencl-book/basic-opencl/online-offline-compilation.html" aria-current="page" class="active sidebar-link">Online/Offline Compilation</a></li><li><a href="/opencl-book/opencl-book/basic-opencl/calling-the-kernel.html" class="sidebar-link">Calling the Kernel</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Advanced OpenCL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/advanced-opencl/opencl-c.html" class="sidebar-link">OpenCL C</a></li><li><a href="/opencl-book/opencl-book/advanced-opencl/opencl-programming-practice.html" class="sidebar-link">OpenCL Programming Practice</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Changes made in OpenCL Specification 1.2</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/opencl-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.0-to-1.1.html" class="sidebar-link">Changes made in update from 1.0 to 1.1</a></li><li><a href="/opencl-book/opencl-book/changes-made-in-opencl-specification-1.2/changes-made-in-update-from-1.1-to-1.2.html" class="sidebar-link">Changes made in update from 1.1 to 1.2</a></li></ul></section></li><li><a href="/opencl-book/opencl-book/references.html" class="sidebar-link">References</a></li><li><a href="/opencl-book/opencl-book/notes.html" class="sidebar-link">Notes</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="online-offline-compilation"><a href="#online-offline-compilation" class="header-anchor">#</a> Online/Offline Compilation</h1> <p>In OpenCL, a kernel can be compiled either online or offline (<strong>Figure 4.1</strong>).</p> <p><strong>Figure 4.1: Offline and Online Compilation</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2022-01-04_at_5.23.59_PM.c8a2674b.png" alt=""></p> <p>The basic difference between the 2 methods is as follows:</p> <p>• Offline: Kernel binary is read in by the host code</p> <p>• Online: Kernel source file is read in by the host code</p> <p>In &quot;offline-compilation&quot;, the kernel is pre-built using an OpenCL compiler, and the generated binary is what gets loaded using the OpenCL API. Since the kernel binary is already built, the time lag between starting the host code and the kernel getting executed is negligible. The problem with this method is that in order to execute the program on various platforms, multiple kernel binaries must be included, thus increasing the size of the executable file.</p> <p>In &quot;online-compilation&quot;, the kernel is built from source during runtime using the OpenCL runtime library. This method is commonly known as JIT (Just in time) compilation. The advantage of this method is that the host-side binary can be distributed in a form that's not device-dependent, and that adaptive compiling of the kernel is possible. It also makes the testing of the kernel easier during development, since it gets rid of the need to compile the kernel each time. However, this is not suited for embedded systems that require real-time processing. Also, since the kernel code is in readable form, this method may not be suited for commercial applications.</p> <p>The OpenCL runtime library contains the set of APIs that performs the above operations. In a way, since OpenCL is a programming framework for heterogeneous environments, the online compilation support should not come as a shock. In fact, a stand-alone OpenCL compiler is not available for the OpenCL environment by NVIDIA, AMD, and Apple. Hence, in order to create a kernel binary in these environments, the built kernels has to be written to a file during runtime by the host program. FOXC on the other hand includes a stand-alone OpenCL kernel compiler, which makes the process of making a kernel binary intuitive.</p> <p>We will now look at sample programs that show the two compilation methods. The first code shows the online compilation version (<strong>List 4.2</strong>).</p> <p><strong>List 4.2: Online Compilation version</strong></p> <div class="language- extra-class"><pre class="language-text"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#ifdef __APPLE__
#include &lt;OpenCL/opencl.h&gt;
#else
#include &lt;CL/cl.h&gt;
#endif

#define MEM_SIZE (128)
#define MAX_SOURCE_SIZE (0x100000)

int main()
{
    cl_platform_id platform_id = NULL;
    cl_device_id device_id = NULL;
    cl_context context = NULL;
    cl_command_queue command_queue = NULL;
    cl_mem memobj = NULL;
    cl_program program = NULL;
    cl_kernel kernel = NULL;
    cl_uint ret_num_devices;
    cl_uint ret_num_platforms;
    cl_int ret;

    float mem[MEM_SIZE];

    FILE *fp;
    const char fileName[] = &quot;./kernel.cl&quot;;
    size_t source_size;
    char *source_str;
    cl_int i;

    /* Load kernel source code */
    fp = fopen(fileName, &quot;r&quot;);
    if (!fp)
    {
        fprintf(stderr, &quot;Failed to load kernel.¥n&quot;);
        exit(1);
    }
    source_str = (char *)malloc(MAX_SOURCE_SIZE);
    source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
    fclose(fp);

    /*Initialize Data */
    for (i = 0; i &lt; MEM_SIZE; i++)
    {
        mem[i] = i;
    }

    /* Get platform/device information */
    ret = clGetPlatformIDs(1, &amp;platform_id, &amp;ret_num_platforms);
    ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &amp;device_id, &amp;ret_num_devices);

    /* Create OpenCL Context */
    context = clCreateContext(NULL, 1, &amp;device_id, NULL, NULL, &amp;ret);

    /* Create Command Queue */
    command_queue = clCreateCommandQueue(context, device_id, 0, &amp;ret);

    /* Create memory buffer*/
    memobj = clCreateBuffer(context, CL_MEM_READ_WRITE, MEM_SIZE * sizeof(float), NULL, &amp;ret);

    /* Transfer data to memory buffer */
    ret = clEnqueueWriteBuffer(command_queue, memobj, CL_TRUE, 0, MEM_SIZE * sizeof(float), mem, 0, NULL, NULL);

    /* Create Kernel program from the read in source */
    program = clCreateProgramWithSource(context, 1, (const char **)&amp;source_str, (const size_t *)&amp;source_size, &amp;ret);

    /* Build Kernel Program */
    ret = clBuildProgram(program, 1, &amp;device_id, NULL, NULL, NULL);

    /* Create OpenCL Kernel */
    kernel = clCreateKernel(program, &quot;vecAdd&quot;, &amp;ret);

    /* Set OpenCL kernel argument */
    ret = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *)&amp;memobj);

    size_t global_work_size[3] = {MEM_SIZE, 0, 0};
    size_t local_work_size[3] = {MEM_SIZE, 0, 0};

    /* Execute OpenCL kernel */
    ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL, global_work_size, local_work_size, 0, NULL, NULL);

    /* Transfer result from the memory buffer */
    ret = clEnqueueReadBuffer(command_queue, memobj, CL_TRUE, 0, MEM_SIZE * sizeof(float), mem, 0, NULL, NULL);

    /* Display result */
    for (i = 0; i &lt; MEM_SIZE; i++)
    {
        printf(&quot;mem[%d] : %f¥n&quot;, i, mem[i]);
    }

    /* Finalization */
    ret = clFlush(command_queue);
    ret = clFinish(command_queue);
    ret = clReleaseKernel(kernel);
    ret = clReleaseProgram(program);
    ret = clReleaseMemObject(memobj);
    ret = clReleaseCommandQueue(command_queue);
    ret = clReleaseContext(context);

    free(source_str);

    return 0;
}
</code></pre></div><p>The following code shows the offline compilation version (<strong>List 4.3</strong>).</p> <p><strong>List 4.3 Offline compilation version</strong></p> <div class="language- extra-class"><pre class="language-text"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#ifdef __APPLE__
#include &lt;OpenCL/opencl.h&gt;
#else
#include &lt;CL/cl.h&gt;
#endif

#define MEM_SIZE (128)
#define MAX_BINARY_SIZE (0x100000)

int main()
{
    cl_platform_id platform_id = NULL;
    cl_device_id device_id = NULL;
    cl_context context = NULL;
    cl_command_queue command_queue = NULL;
    cl_mem memobj = NULL;
    cl_program program = NULL;
    cl_kernel kernel = NULL;
    cl_uint ret_num_devices;
    cl_uint ret_num_platforms;
    cl_int ret;

    float mem[MEM_SIZE];

    FILE *fp;
    char fileName[] = &quot;./kernel.clbin&quot;;
    size_t binary_size;
    char *binary_buf;
    cl_int binary_status;
    cl_int i;

    /* Load kernel binary */
    fp = fopen(fileName, &quot;r&quot;);
    if (!fp)
    {
        fprintf(stderr, &quot;Failed to load kernel.¥n&quot;);
        exit(1);
    }
    binary_buf = (char *)malloc(MAX_BINARY_SIZE);
    binary_size = fread(binary_buf, 1, MAX_BINARY_SIZE, fp);
    fclose(fp);

    /* Initialize input data */
    for (i = 0; i &lt; MEM_SIZE; i++)
    {
        mem[i] = i;
    }

    /* Get platform/device information */
    ret = clGetPlatformIDs(1, &amp;platform_id, &amp;ret_num_platforms);
    ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &amp;device_id, &amp;ret_num_devices);

    /* Create OpenCL context*/
    context = clCreateContext(NULL, 1, &amp;device_id, NULL, NULL, &amp;ret);

    /* Create command queue */
    command_queue = clCreateCommandQueue(context, device_id, 0, &amp;ret);

    /* Create memory buffer */
    memobj = clCreateBuffer(context, CL_MEM_READ_WRITE, MEM_SIZE * sizeof(float), NULL, &amp;ret);

    /* Transfer data over to the memory buffer */
    ret = clEnqueueWriteBuffer(command_queue, memobj, CL_TRUE, 0, MEM_SIZE * sizeof(float), mem, 0, NULL, NULL);

    /* Create kernel program from the kernel binary */
    program = clCreateProgramWithBinary(context, 1, &amp;device_id, (const size_t *)&amp;binary_size,
                                        (const unsigned char **)&amp;binary_buf, &amp;binary_status, &amp;ret);

    /* Create OpenCL kernel */
    kernel = clCreateKernel(program, &quot;vecAdd&quot;, &amp;ret);
    printf(&quot;err:%d¥n&quot;, ret);

    /* Set OpenCL kernel arguments */
    ret = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *)&amp;memobj);

    size_t global_work_size[3] = {MEM_SIZE, 0, 0};
    size_t local_work_size[3] = {MEM_SIZE, 0, 0};

    /* Execute OpenCL kernel */
    ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL, global_work_size, local_work_size, 0, NULL, NULL);

    /* Copy result from the memory buffer */
    ret = clEnqueueReadBuffer(command_queue, memobj, CL_TRUE, 0, MEM_SIZE * sizeof(float), mem, 0, NULL, NULL);

    /* Display results */
    for (i = 0; i &lt; MEM_SIZE; i++)
    {
        printf(&quot;mem[%d] :%f¥n&quot;, i, mem[i]);
    }

    /* Finalization */
    ret = clFlush(command_queue);
    ret = clFinish(command_queue);
    ret = clReleaseKernel(kernel);
    ret = clReleaseProgram(program);
    ret = clReleaseMemObject(memobj);
    ret = clReleaseCommandQueue(command_queue);
    ret = clReleaseContext(context);

    free(binary_buf);

    return 0;
}
</code></pre></div><p>The kernel program performs vector addition. It is shown below in <strong>List 4.4</strong>.</p> <p><strong>List 4.4: Kernel program</strong></p> <div class="language- extra-class"><pre class="language-text"><code>__kernel void vecAdd(__global float *a)
{
    int gid = get_global_id(0);

    a[gid] += a[gid];
}
</code></pre></div><p>We will take a look at the host programs shown in <strong>List 4.2</strong> and <strong>List 4.3</strong>. The two programs are almost identical, so we will focus on their differences.</p> <p>The first major difference is the fact that the kernel source code is read in the online compile version (<strong>List 4.5</strong>).</p> <p><strong>List 4.5: Online compilation version - Reading the kernel source code</strong></p> <blockquote><p>035: fp = fopen(fileName, &quot;r&quot;);</p> <p>036: if (!fp) {</p> <p>037: fprintf(stderr, &quot;Failed to load kernel.¥n&quot;);</p> <p>038: exit(1);</p> <p>039: }</p> <p>040: source_str = (char *)malloc(MAX_SOURCE_SIZE);</p> <p>041: source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);</p> <p>042: fclose(fp);</p></blockquote> <p>The source_str variable is a character array that merely contains the content of the source file. In order to execute this code on the kernel, it must be built using the runtime compiler. This is done by the code segment shown below in <strong>List 4.6</strong>.</p> <p><strong>List 4.6: Online compilation version - Create kernel program</strong></p> <blockquote><p>065: /* Create kernel program from the source */</p> <p>066: program = clCreateProgramWithSource(context, 1, (const char **)&amp;source_str, (const size_t *)&amp;source_size, &amp;ret);</p> <p>067:</p> <p>068: /* Build kernel program */</p> <p>069: ret = clBuildProgram(program, 1, &amp;device_id, NULL, NULL, NULL);</p></blockquote> <p>The program is first created from source, and then built.</p> <p>Next, we will look at the source code for the offline compilation version (<strong>List 4.7</strong>).</p> <p><strong>List 4.7: Offline compilation - Reading the kernel binary</strong></p> <blockquote><p>036: fp = fopen(fileName, &quot;r&quot;);</p> <p>037: if (!fp) {</p> <p>038: fprintf(stderr, &quot;Failed to load kernel.¥n&quot;);</p> <p>039: exit(1);</p> <p>040: }</p> <p>041: binary_buf = (char *)malloc(MAX_BINARY_SIZE);</p> <p>042: binary_size = fread(binary_buf, 1, MAX_BINARY_SIZE, fp);</p> <p>043: fclose(fp);</p></blockquote> <p>The code looks very similar to the online version, since the data is being read into a buffer of type char.</p> <p>The difference is that the data on the buffer can be directly executed. This means that the kernel source code must be compiled beforehand using an OpenCL compiler. The Intel OpenCL Offline Compiler contained Intel OpenCL SDK 1.5 can be used to create a binary of the kernel (<strong>Figure 4.2</strong>).</p> <p><strong>Figure 4.2: Intel OpenCL Offline Compiler</strong></p> <p><img src="/opencl-book/assets/img/Screen_Shot_2022-01-04_at_6.16.28_PM.73d7f898.png" alt=""></p> <blockquote><p>/path-to-foxc/bin/foxc -o kernel.clbin kernel.cl</p></blockquote> <p>The online compilation version required 2 steps to build the kernel program. With offline compilation, the clCreateProgramWithSource() is replaced with clCreateProgramWithBinary.</p> <blockquote><p>067: program = clCreateProgramWithBinary(context, 1, &amp;device_id, (const size_t *)&amp;binary_size,</p> <p>068: (const unsigned char **)&amp;binary_buf, &amp;binary_status, &amp;ret);</p></blockquote> <p>Since the kernel is already built, there is no reason for another build step as in the online compilation version.</p> <p>To summarize, in order to change the method of compilation from online to offline, the following steps are followed:</p> <p>1. Read the kernel as a binary</p> <p>2. Change clCreateProgramWithSource() to clCreateProgramWithBinary()</p> <p>3. Get rid of clBuildProgram()</p> <p>This concludes the differences between the two methods. See Chapter 8 for the details on the APIs used inside the sample codes.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/opencl-book/opencl-book/basic-opencl/basic-program-flow.html" class="prev">
        Basic Program Flow
      </a></span> <span class="next"><a href="/opencl-book/opencl-book/basic-opencl/calling-the-kernel.html">
        Calling the Kernel
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/opencl-book/assets/js/app.044fec5c.js" defer></script><script src="/opencl-book/assets/js/2.e23f9d0e.js" defer></script><script src="/opencl-book/assets/js/15.a1675395.js" defer></script>
  </body>
</html>
