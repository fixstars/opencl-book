(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{494:function(e,t,n){"use strict";n.r(t);var a=n(56),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"changes-made-in-update-from-1-0-to-1-1"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#changes-made-in-update-from-1-0-to-1-1"}},[e._v("#")]),e._v(" Changes made in update from 1.0 to 1.1")]),e._v(" "),n("p",[e._v("As of this writing (2012/1/17), the latest available OpenCL Specification is 1.2, revision 15. This chapter will walk through the changes made in the specification from 1.0 to 1.2.")]),e._v(" "),n("p",[e._v("This section will highlight the changes made between the 1.0 and 1.1 specifications. In particular, changes in the platform layer/runtime, OpenCL C, deprecated functions, as well as the extensions will be discussed.")]),e._v(" "),n("h2",{attrs:{id:"changes-in-the-opencl-platform-layer-and-the-runtime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#changes-in-the-opencl-platform-layer-and-the-runtime"}},[e._v("#")]),e._v(" "),n("em",[e._v("Changes in the OpenCL Platform Layer and the Runtime")])]),e._v(" "),n("p",[n("strong",[e._v("clGetDeviceInfo()")])]),e._v(" "),n("p",[e._v("This API is used to obtain information about the OpenCL device installed in the system.")]),e._v(" "),n("blockquote",[n("p",[e._v("Cl_int clGetDeviceInfo(cl_device_id device, // device returned by clGetDeviceIDs")]),e._v(" "),n("p",[e._v("cl_device_info param_name, // enum of the parameter to obtain")]),e._v(" "),n("p",[e._v("size_t param_value_size, // size of buffer allocated for param_value")]),e._v(" "),n("p",[e._v("void *param_value, // returned param value")]),e._v(" "),n("p",[e._v("size_t *param_value_size_ret) // actual size of param_value returned")])]),e._v(" "),n("p",[e._v("The OpenCL 1.1 specification allows the following additional parameters to be obtained.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("cl_device_info")]),e._v(" "),n("th",[e._v("Return Type")]),e._v(" "),n("th",[e._v("Description")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("CL_DEVICE_NATIVE_VECTOR_WIDTH_ {CHAR | SHORT | INT | LONG | FLOAT | DOUBLE | HALF}")]),e._v(" "),n("td",[e._v("cl_int")]),e._v(" "),n("td",[e._v("Returns the native ISA vector width")])]),e._v(" "),n("tr",[n("td",[e._v("CL_DEVICE_HOST_UNIFIED_MEMORY")]),e._v(" "),n("td",[e._v("bool")]),e._v(" "),n("td",[e._v("Returns CL_TRUE if the device and the host have a")])]),e._v(" "),n("tr",[n("td"),e._v(" "),n("td"),e._v(" "),n("td",[e._v("unified memory subsystem, and CL_FALSE otherwise.")])]),e._v(" "),n("tr",[n("td",[e._v("CL_DEVICE_OPENCL_C_VERSION")]),e._v(" "),n("td",[e._v("char[]")]),e._v(" "),n("td",[e._v("Returns the highest OpenCL C version supported by the compiler for this device. Note that the device itself may support a higher version, which can be obtained using CL_DEVICE_VERSION.")])])])]),e._v(" "),n("p",[e._v("The return types are changed for the following APIs.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("cl_device_info")]),e._v(" "),n("th",[e._v("Return Type")]),e._v(" "),n("th",[e._v("Description")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("CL_DEVICE_MAX_PARAMETER_SIZE")]),e._v(" "),n("td",[e._v("size_t")]),e._v(" "),n("td",[e._v("Max size in bytes of the arguments that can be passed to a kernel. The minimum value has increased from 256 to 1024 in OpenCL 1.1.")])]),e._v(" "),n("tr",[n("td",[e._v("CL_DEVICE_LOCAL_MEM_SIZE")]),e._v(" "),n("td",[e._v("cl_ulong")]),e._v(" "),n("td",[e._v("Size of local memory area in bytes. The minimum value is 32 KB.")])])])]),e._v(" "),n("p",[n("strong",[e._v("clGetContextInfo()")])]),e._v(" "),n("p",[e._v("This API is used to obtain information about an OpenCL context.")]),e._v(" "),n("blockquote",[n("p",[e._v("Cl_int clGetContextInfo( cl_context context, // Context object")]),e._v(" "),n("p",[e._v("Cl_context_info param_name, //enum of the parameter to obtain")]),e._v(" "),n("p",[e._v("Size_t param_value_size, // size of buffer allocated for param_value")]),e._v(" "),n("p",[e._v("Void *param_value, // returned param value")]),e._v(" "),n("p",[e._v("Size_t *param_value_size_ret) // actual size of param_value returned")])]),e._v(" "),n("p",[e._v("The OpenCL 1.1 specification allows the following additional parameters to be obtained.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("cl_context_info")]),e._v(" "),n("th",[e._v("Return Type")]),e._v(" "),n("th",[e._v("Description")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("CL_CONTEXT_NUM_DEVICES")]),e._v(" "),n("td",[e._v("cl_uint")]),e._v(" "),n("td",[e._v("Returns the number of devices associated with context.")])])])]),e._v(" "),n("p",[n("strong",[e._v("Image format")])]),e._v(" "),n("p",[e._v("When creating an image object using clCreateImage2D(), clCreateImage3D(), etc, a pointer to the struct cl_image_format is passed in, which specifies the properties of the image to be transferred to the object.")]),e._v(" "),n("blockquote",[n("p",[e._v("typedef struct _cl_image_format {")]),e._v(" "),n("p",[e._v("cl_channel_order image_channel_order; // Order of channels")]),e._v(" "),n("p",[e._v("cl_channel_type image_channel_data_type; // Channel component information")]),e._v(" "),n("p",[e._v("} cl_image_format;")])]),e._v(" "),n("p",[e._v("The OpenCL 1.1 specification allows the following additional parameters to be obtained.")]),e._v(" "),n("p",[e._v("* CL_Rx")]),e._v(" "),n("p",[e._v("* CL_RGx")]),e._v(" "),n("p",[e._v("* CL_RGBx")]),e._v(" "),n("p",[e._v("These channel layouts are the same as CL_R, CL_RG, CL_RGB supported in OpenCL 1.0, except for the fact that the value of alpha is set to 0.0f at the edges. (See Figure 5.6, 5.9 from Chapter 5)")]),e._v(" "),n("p",[n("strong",[e._v("clCreateSubBuffer()")])]),e._v(" "),n("p",[e._v("This function allows a buffer object to be created within an existing buffer object.")]),e._v(" "),n("blockquote",[n("p",[e._v("cl_mem clCreateSubBuffer( cl_mem buffer, // Buffer object")]),e._v(" "),n("p",[e._v("cl_mem_flags flags, // Memory flags")]),e._v(" "),n("p",[e._v("cl_buffer_create_type buffer_create_type, // Buffer type")]),e._v(" "),n("p",[e._v("const void *buffer_create_info, // Buffer info")]),e._v(" "),n("p",[e._v("cl_int *errcode_ret) // Error code")])]),e._v(" "),n("p",[e._v("The only type that can be passed in as cl_buffer_create_type is the following.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("cl_buffer_create_type")]),e._v(" "),n("th",[e._v("Description")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("CL_BUFFER_CREATE_TYPE_REGION")]),e._v(" "),n("td",[e._v("Create a buffer object that represents a specific region in buffer.")])])])]),e._v(" "),n("p",[e._v("The buffer region is specified in buffer_create_info, which is a struct as described below:")]),e._v(" "),n("blockquote",[n("p",[e._v("typedef struct _cl_buffer_region {")]),e._v(" "),n("p",[e._v("size_t origin; // Offset into the buffer (in Bytes)")]),e._v(" "),n("p",[e._v("size_t size; // Size of the buffer (in Bytes)")]),e._v(" "),n("p",[e._v("} cl_buffer_region;")])]),e._v(" "),n("p",[e._v("If the origin and size is set such that the SubBuffer object region reaches beyond the boundary of the original buffer, CL_INVALID_VALUE will be returned.")]),e._v(" "),n("p",[e._v("A SubBuffer object is used to identify a region of the main Buffer, which simplifies the process when working only that region. Note, however, that the SubBuffer cannot be specified in the first parameter to this function, to create a sub-SubBuffer.")]),e._v(" "),n("p",[n("strong",[e._v("New ways to access Buffer objects")])]),e._v(" "),n("p",[e._v("To access a rectangular region from a buffer objects, the following methods were added: clEnqueueReadBufferRect(), clEnqueueWriteBufferRect(), clEnqueueCopyBufferRect().")]),e._v(" "),n("p",[n("strong",[e._v("clSetMObjectDestructorCallback()")])]),e._v(" "),n("p",[e._v("This function can be called to register a callback to be called when the destructor for the memory object is called.")]),e._v(" "),n("blockquote",[n("p",[e._v("cl_int clSetMemObjectDestructorCallback(cl_mem memobj, // Memory object")]),e._v(" "),n("p",[e._v("void (CL_CALLBACK *pfn_notify) (cl_mem memobj, void *user_data), // Callback")]),e._v(" "),n("p",[e._v("void *user_data) // Argument passed into to the callback")])]),e._v(" "),n("p",[e._v("This function registers a user callback function on a callback stack associated with the memory object.")]),e._v(" "),n("p",[e._v("Since it is a stack, the registered callback functions are called in the reverse order in which they were registered, before the object itself is deleted. "),n("em",[e._v("user_data")]),e._v(" is passed in as an argument for when "),n("em",[e._v("pfn_notify")]),e._v(" is called. This value can be set to NULL if no argument is required. The callback function may be called asynchronously by the OpenCL implementation. The application must make sure the callback function is thread-safe.")]),e._v(" "),n("p",[n("strong",[e._v("clBuildProgram()")])]),e._v(" "),n("p",[e._v("The OpenCL C version can now be specified when building a program object.")]),e._v(" "),n("blockquote",[n("p",[e._v("-cl-std=")])]),e._v(" "),n("p",[e._v('The OpenCL C version can be set, for example, by passing in "-cl=CL1.1" in the build option. If this is not set, the kernel will be built with using the value of CL_DEVICE_OPENCL_C_VERSION. If the specified OpenCL C exceeds that of CL_DEVICE_OPENCL_C_VERSION, which is the latest version specified, the build will fail with the appropriate code.')]),e._v(" "),n("p",[n("strong",[e._v("clGetKernelWorkGroupInfo()")])]),e._v(" "),n("p",[e._v("This function retrieves information about the kernel object that may be specific to a device.")]),e._v(" "),n("blockquote",[n("p",[e._v("cl_int clGetKernelWorkGroupInfo(cl_kernel kernel, // kernel object")]),e._v(" "),n("p",[e._v("cl_device_id device, // device")]),e._v(" "),n("p",[e._v("cl_kernel_work_group_info param_name, // the parameter to obtain")]),e._v(" "),n("p",[e._v("size_t param_value_size, // size of buffer allocated for param_value")]),e._v(" "),n("p",[e._v("void *param_value, // returned param value")]),e._v(" "),n("p",[e._v("size_t *param_value_size_ret) // actual size of param value returned")])]),e._v(" "),n("p",[e._v("The OpenCL 1.1 specification allows the following additional parameters to be obtained.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("cl_kernel_work_group_info")]),e._v(" "),n("th",[e._v("Return Type")]),e._v(" "),n("th",[e._v("Description")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("CL_KERNEL_PREFERRED_WORK_GROUP_ SIZE_MULTIPLE")]),e._v(" "),n("td",[e._v("size_t")]),e._v(" "),n("td",[e._v("Returns the preferred multiple of work-group size for launch.")])])])]),e._v(" "),n("p",[e._v("Calling this function provides a performance hint for when determining the workgroup size to use.")]),e._v(" "),n("blockquote",[n("p",[e._v("cl_event clCreateUserEvent(cl_context context, // associated context")]),e._v(" "),n("p",[e._v("cl_int *errcode_ret) // Error code")])]),e._v(" "),n("p",[e._v("Once created, the status of the event object is set to CL_SUBMITTED. This status can be changed by calling the following.")]),e._v(" "),n("blockquote",[n("p",[e._v("cl_int clSetUserEventStatus(cl_event event, // event for which to set status")]),e._v(" "),n("p",[e._v("cl_int execution_status) // status to set to")])]),e._v(" "),n("p",[e._v("The values that can be set for "),n("em",[e._v("execution_status")]),e._v(" is CL_COMPLETE for successful operation, or a negative number representing an error. The function may only be called once to change the status of the event.")]),e._v(" "),n("p",[e._v("The introduction of user event allows for a command to be executed on the device only after the user event has finished.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Column - More about Event Objects")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[n("p",[e._v("User Event is a type of an Event Object, which holds one of the following states when placed in a command queue using an OpenCL runtime: ")]),n("p",[e._v("* CL_QUEUE: This indicates that the command has been enqueued in the command queue. This is the initial status for all events except user events. ")]),n("p",[e._v("* CL_SUBMITTED: This is the initial state for all user events. For all other events, this indicates that the command has been submitted by the host to the device. ")]),n("p",[e._v("* CL_RUNNING: The device is currently executing the command. ")]),n("p",[e._v("* CL_COMPLETE: The command has executed successfully. ")]),n("p",[e._v("* Error Code: The command has returned with an error. ")])])])])]),e._v(" "),n("p",[n("strong",[e._v("clSetEventCallback()")])]),e._v(" "),n("p",[e._v("This function sets a callback to be called based on the event status.")]),e._v(" "),n("blockquote",[n("p",[e._v("cl_int clSetEventCallback(cl_event event, // associated event")]),e._v(" "),n("p",[e._v("cl_int command_exec_callback_type, // status for which the callback is registered")]),e._v(" "),n("p",[e._v("void (CL_CALLBACK *pfn_event_notify) (cl_event event,")]),e._v(" "),n("p",[e._v("// event object that calls the callback")]),e._v(" "),n("p",[e._v("cl_int event_command_exec_status, //status of command for which this callback function is invoked")]),e._v(" "),n("p",[e._v("void *user_data), // user-supplied data")]),e._v(" "),n("p",[e._v("void *user_data) // user-supplied data")])]),e._v(" "),n("p",[e._v("The callback function (pfn_event_notify) is triggered when the associated event enters the status specified in the 2nd argument (command_exec_callback_type).")]),e._v(" "),n("p",[e._v("The only value that can be passed in the 2nd argument is CL_COMPLETE. (OpenCL 1.2 allows CL_SUBMITTED and CL_RUNNING). The callback function may be called asynchronously by the OpenCL implementation. The application must make sure the callback function is thread-safe.")]),e._v(" "),n("p",[n("strong",[e._v("clEnqueueNDRangeKernel()")])]),e._v(" "),n("p",[e._v("This function is used to execute a kernel on the device. In the OpenCL 1.0 specification, the only argument that can be set as the 4th parameter (global_work_offset) was NULL. In OpenCL 1.1, an offset value may be entered, which is used to compute the global ID of the work-item. When NULL is set, the offset is set to 0 for each dimension.")]),e._v(" "),n("p",[n("strong",[e._v("Thread-Safety")])]),e._v(" "),n("p",[e._v("All function call is now thread-safe, with the exception of clSetKernelArg().")]),e._v(" "),n("h2",{attrs:{id:"changes-in-opencl-c"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#changes-in-opencl-c"}},[e._v("#")]),e._v(" "),n("em",[e._v("Changes in OpenCL C")])]),e._v(" "),n("p",[n("strong",[e._v("3-element vectors")])]),e._v(" "),n("p",[e._v("OpenCL C supports the following data types: char, uchar, short, ushort, int, uint, float, long, and ulong. Vector data type can be defined by concatenating a data type with an integer value representing the number of elements in the vector. For example, a vector data type consisting of 4 float values is defined as float4.")]),e._v(" "),n("p",[e._v("OpenCL 1.0 supported 2, 4, 8, and 16 as the number of elements. OpenCL 1.1 now allows a vector with 3-elements to be created.")]),e._v(" "),n("p",[n("strong",[e._v("New built-in functions")])]),e._v(" "),n("p",[e._v("The following built-in functions are now available:")]),e._v(" "),n("ul",[n("li",[e._v("size_t get_global_offset(uint dimindx)")])]),e._v(" "),n("p",[e._v("Retrieves the offset value which is set as the 4th argument to clEnqueueNDRangeKernel(). dimindx is the dimension from which to retrieve the offset from.")]),e._v(" "),n("ul",[n("li",[e._v("gentype maxmag(gentype x, gentype y)")])]),e._v(" "),n("p",[e._v("Returns gentype with a higher magnitude. Returns x if |x| > |y|, y if |y| > |x|, otherwise fmax(x,y). The gentype that is referred to correspond to one of: float, float2, float3, float4, float8, and float16. In OpenCL 1.2, double, double2, double3, double4, double8, and double16 are supported.")]),e._v(" "),n("ul",[n("li",[e._v("getntype minmag(gentype x, gentype y)")])]),e._v(" "),n("p",[e._v("Returns gentype with a lower magnitude. Returns x if |x| C |y|, y if |y| < |x|, otherwise fmin(x,y). The gentype corresponds to one of: float, float2, float3, float4, float8, and float16. In OpenCL 1.2, double, double2, double3, double4, double8, and double16 are supported.")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("gentype clamp(gentype x, gentype minval, genotype maxval)")])]),e._v(" "),n("li",[n("p",[e._v("genotype clamp(gentype x, sgentype minval, sgentype maxval)")])])]),e._v(" "),n("p",[e._v("Clamps the value of "),n("em",[e._v("x")]),e._v(" to minval and maxval. The gentype corresponds to one of: char, char|2|3|4|8|16|, uchar, uchar|2|3|4|8|16|, short, short|2|3|4|8|16|, ushort, ushort|2|3|4|8|16|, int, int|2|3|4|8|16|, uint, uint|2|3|4|8|16|, long, long|2|3|4|8|16|, ulong, ulong|2|3|4|8|16|. sgentype refers to the scalar version of gentype, which is one of: char, uchar, short, ushort, int, uint, long, ulong. The behavior is undefined if "),n("em",[e._v("minval")]),e._v(" > "),n("em",[e._v("maxval")]),e._v(".")]),e._v(" "),n("p",[n("strong",[e._v("Extension now a core feature")])]),e._v(" "),n("p",[e._v("The following features that were available as extensions in OpenCL 1.0 are now supported as core features:")]),e._v(" "),n("ul",[n("li",[e._v("cl_khr_byte_addressable_store")])]),e._v(" "),n("p",[e._v("In OpenCL 1.0, writing to memory using data types with size less than 32-bits to access the address, which includes char, uchar, uchar2, short, ushort, and half, were offered as extensions. OpenCL 1.1 now supports these by default.")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("cl_khr_global_int32_base_atomics")])]),e._v(" "),n("li",[n("p",[e._v("cl_khr_global_int32_extended_atomics")])]),e._v(" "),n("li",[n("p",[e._v("cl_khr_local_int32_base_atomics")])]),e._v(" "),n("li",[n("p",[e._v("cl_khr_local_int32_extended_atomics")])])]),e._v(" "),n("p",[e._v("In OpenCL 1.0, atomic operations of int, uint, and float data in __global or __local memory were offered as extensions. OpenCL 1.1 now supports these by default. Note, however, that the name of the function has been changed from atom_xxx to atomic_xxx.")]),e._v(" "),n("p",[n("strong",[e._v("MACROS")])]),e._v(" "),n("p",[e._v("The following macros are defined, which can be used to switch kernel code depending on the OpenCL version.")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("CL_VERSION_1_0: substitutes the integer 100 reflecting the OpenCL 1.0 version")])]),e._v(" "),n("li",[n("p",[e._v("CL_VERSION_1_1: substitutes the integer 110 reflecting the OpenCL 1.1 version.")])])]),e._v(" "),n("p",[e._v("In OpenCL 1.2 the following will be defined:")]),e._v(" "),n("ul",[n("li",[e._v("CL_VERSION_1_2: substitutes the integer 120 reflecting the OpenCL 1.2 version.")])]),e._v(" "),n("p",[e._v("The above value can be compared with __OPENCL_VERSION__ to switch between OpenCL versions.")]),e._v(" "),n("h2",{attrs:{id:"deprecated-functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#deprecated-functions"}},[e._v("#")]),e._v(" "),n("em",[e._v("Deprecated Functions")])]),e._v(" "),n("p",[e._v("The following features were deprecated in OpenCL 1.1:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("clSetCommandQueueProperty()")])]),e._v(" "),n("li",[n("p",[e._v("__ROUNDING_MODE__ macro")])]),e._v(" "),n("li",[n("p",[e._v('"-cl-strict-aliasing" as an option to clBuildProgram()')])])]),e._v(" "),n("p",[n("strong",[e._v("Changes in Extensions")])]),e._v(" "),n("p",[e._v("The following extensions became available in OpenCL 1.1:")]),e._v(" "),n("ul",[n("li",[e._v("cl_khr_gl_event")])]),e._v(" "),n("p",[e._v("While there are other extensions that allows memory objects to be shared between OpenGL and OpenCL, this extension allows creating OpenCL event objects linked to OpenGL fence sync objects, potentially improving efficiency of sharing images and buffers between the two APIs.")]),e._v(" "),n("ul",[n("li",[e._v("cl_khr_d3d10_sharing \\")])]),e._v(" "),n("p",[e._v("This extension provides interoperability between OpenCL and Direct3D 10. This is designed to function analogously to the OpenGL interoperability, providing functions for sharing memory objects, as well as other utility functions.")]),e._v(" "),n("p",[n("strong",[e._v("Changes in OpenCL Embedded Profile")])]),e._v(" "),n("p",[e._v("Support for 64bit integer is now an option.")])])}),[],!1,null,null,null);t.default=o.exports}}]);