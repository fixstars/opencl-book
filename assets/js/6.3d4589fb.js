(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{399:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_7.58.32_AM.a6758b61.png"},400:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_7.59.59_AM.8a122a48.png"},401:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_8.20.51_AM.596eb487.png"},402:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_8.26.20_AM.75f194ee.png"},403:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_8.30.01_AM.d4e42b2e.png"},404:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_8.30.50_AM.3b8229ff.png"},405:function(e,t,n){e.exports=n.p+"assets/img/Screen_Shot_2022-01-05_at_8.42.40_AM.7b09470c.png"},490:function(e,t,n){"use strict";n.r(t);var a=n(56),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"calling-the-kernel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#calling-the-kernel"}},[e._v("#")]),e._v(" Calling the Kernel")]),e._v(" "),a("p",[a("em",[e._v("Data Parallelism and Task Parallelism")])]),e._v(" "),a("p",[e._v('As stated in the "1-3-3 Types of Parallelism" section, parallelizable code is either "Data Parallel" or "Task Parallel". In OpenCL, the difference between the two is whether the same kernel or different kernels are executed in parallel. The difference becomes obvious in terms of execution time when executed on the GPU.')]),e._v(" "),a("p",[e._v("At present, most GPUs contain multiple processors, but hardware such as instruction fetch and program counters are shared across the processors. For this reason, the GPUs are incapable of running different tasks in parallel.")]),e._v(" "),a("p",[e._v("As shown in "),a("strong",[e._v("Figure 4.3")]),e._v(", when multiple processors perform the same task, the number of tasks equal to the number of processors can be performed at once. "),a("strong",[e._v("Figure 4.4")]),e._v(" shows the case when multiple tasks are scheduled to be performed in parallel on the GPU. Since the processors can only process the same set of instructions across the cores, the processors scheduled to process Task B must be in idle mode until Task A is finished.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 4.3: Efficient use of the GPU")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(399),alt:""}})]),e._v(" "),a("p",[e._v("For data parallel tasks suited for a device like the GPU, OpenCL provides an API to run the same kernel across multiple processors, called clEnqueueNDRangeKernel(). When developing an application, the task type and the hardware need to be considered wisely, and use the appropriate API function.")]),e._v(" "),a("p",[e._v("This section will use vector-ized arithmetic operation to explain the basic method of implementations for data parallel and task parallel commands. The provided sample code is meant to illustrate the parallelization concepts.")]),e._v(" "),a("p",[e._v("The sample code performs the basic arithmetic operations, which are addition, subtraction, multiplication and division, between float values. The overview is shown in "),a("strong",[e._v("Figure 4.5")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Figure 4.5: Basic arithmetic operations between floats")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(400),alt:""}})]),e._v(" "),a("p",[e._v("As the figure shows, the input data consists of 2 sets of 4x4 matrices A and B. The output data is a 4x4 matrix C.")]),e._v(" "),a("p",[e._v("We will first show the data-parallel implementation ("),a("strong",[e._v("List 4.8")]),e._v(", "),a("strong",[e._v("List 4.9")]),e._v("). This program treats each row of data as one group in order to perform the computation.")]),e._v(" "),a("p",[a("strong",[e._v("List 4.8: Data parallel model - kernel dataParallel.cl")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("__kernel void dataParallel(__global float *A, __global float *B, __global float *C)\n{\n    int base = 4 * get_global_id(0);\n\n    C[base + 0] = A[base + 0] + B[base + 0];\n    C[base + 1] = A[base + 1] - B[base + 1];\n    C[base + 2] = A[base + 2] * B[base + 2];\n    C[base + 3] = A[base + 3] / B[base + 3];\n}\n")])])]),a("p",[a("strong",[e._v("List 4.9: Data parallel model - host dataParallel.c")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#include <stdio.h>\n#include <stdlib.h>\n\n#ifdef __APPLE__\n#include <OpenCL/opencl.h>\n#else\n#include <CL/cl.h>\n#endif\n\n#define MAX_SOURCE_SIZE (0x100000)\n\nint main()\n{\n    cl_platform_id platform_id = NULL;\n    cl_device_id device_id = NULL;\n    cl_context context = NULL;\n    cl_command_queue command_queue = NULL;\n    cl_mem Amobj = NULL;\n    cl_mem Bmobj = NULL;\n    cl_mem Cmobj = NULL;\n    cl_program program = NULL;\n    cl_kernel kernel = NULL;\n    cl_uint ret_num_devices;\n    cl_uint ret_num_platforms;\n    cl_int ret;\n\n    int i, j;\n    float *A;\n    float *B;\n    float *C;\n\n    A = (float *)malloc(4 * 4 * sizeof(float));\n    B = (float *)malloc(4 * 4 * sizeof(float));\n    C = (float *)malloc(4 * 4 * sizeof(float));\n\n    FILE *fp;\n    const char fileName[] = "./dataParallel.cl";\n    size_t source_size;\n    char *source_str;\n\n    /* Load kernel source file */\n    fp = fopen(fileName, "r");\n    if (!fp)\n    {\n        fprintf(stderr, "Failed to load kernel.¥n");\n        exit(1);\n    }\n    source_str = (char *)malloc(MAX_SOURCE_SIZE);\n    source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);\n    fclose(fp);\n\n    /* Initialize input data */\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            A[i * 4 + j] = i * 4 + j + 1;\n            B[i * 4 + j] = j * 4 + i + 1;\n        }\n    }\n\n    /* Get Platform/Device Information \nret = clGetPlatformIDs(1, &platform_id, &ret_num_platforms); \nret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &device_id, &ret_num_devices); \n\n/* Create OpenCL Context */\n    context = clCreateContext(NULL, 1, &device_id, NULL, NULL, &ret);\n\n    *Create command queue * /\n        command_queue = clCreateCommandQueue(context, device_id, 0, &ret);\n\n    *Create Buffer Object * /\n        Amobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * 4 * sizeof(float), NULL, &ret);\n    Bmobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * 4 * sizeof(float), NULL, &ret);\n    Cmobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * 4 * sizeof(float), NULL, &ret);\n\n    /* Copy input data to the memory buffer */\n    ret = clEnqueueWriteBuffer(command_queue, Amobj, CL_TRUE, 0, 4 * 4 * sizeof(float), A, 0, NULL, NULL);\n    ret = clEnqueueWriteBuffer(command_queue, Bmobj, CL_TRUE, 0, 4 * 4 * sizeof(float), B, 0, NULL, NULL);\n\n    /* Create kernel program from source file*/\n    program = clCreateProgramWithSource(context, 1, (const char **)&source_str, (const size_t *)&source_size, &ret);\n    ret = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);\n\n    /* Create data parallel OpenCL kernel */\n    kernel = clCreateKernel(program, "dataParallel", &ret);\n\n    /* Set OpenCL kernel arguments */\n    ret = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *)&Amobj);\n    ret = clSetKernelArg(kernel, 1, sizeof(cl_mem), (void *)&Bmobj);\n    ret = clSetKernelArg(kernel, 2, sizeof(cl_mem), (void *)&Cmobj);\n\n    size_t global_item_size = 4;\n    size_t local_item_size = 1;\n\n    /* Execute OpenCL kernel as data parallel */\n    ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL,\n                                 &global_item_size, &local_item_size, 0, NULL, NULL);\n\n    /* Transfer result to host */\n    ret = clEnqueueReadBuffer(command_queue, Cmobj, CL_TRUE, 0, 4 * 4 * sizeof(float), C, 0, NULL, NULL);\n\n    /* Display Results */\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            printf("%7.2f ", C[i * 4 + j]);\n        }\n        printf("¥n");\n    }\n\n    /* Finalization */\n    ret = clFlush(command_queue);\n    ret = clFinish(command_queue);\n    ret = clReleaseKernel(kernel);\n    ret = clReleaseProgram(program);\n    ret = clReleaseMemObject(Amobj);\n    ret = clReleaseMemObject(Bmobj);\n    ret = clReleaseMemObject(Cmobj);\n    ret = clReleaseCommandQueue(command_queue);\n    ret = clReleaseContext(context);\n\n    free(source_str);\n\n    free(A);\n    free(B);\n    free(C);\n\n    return 0;\n}\n')])])]),a("p",[e._v("Next, we will show the task parallel version of the same thing ("),a("strong",[e._v("List 4.10")]),e._v(", "),a("strong",[e._v("List 4.11")]),e._v("). In this sample, the tasks are grouped according to the type of arithmetic operation being performed.")]),e._v(" "),a("p",[a("strong",[e._v("List 4.10: Task parallel model - kernel taskParallel.cl")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("__kernel void taskParallelAdd(__global float *A, __global float *B, __global float *C)\n{\n    int base = 0;\n\n    C[base + 0] = A[base + 0] + B[base + 0];\n    C[base + 4] = A[base + 4] + B[base + 4];\n    C[base + 8] = A[base + 8] + B[base + 8];\n    C[base + 12] = A[base + 12] + B[base + 12];\n}\n\n__kernel void taskParallelSub(__global float *A, __global float *B, __global float *C)\n{\n    int base = 1;\n\n    C[base + 0] = A[base + 0] - B[base + 0];\n    C[base + 4] = A[base + 4] - B[base + 4];\n    C[base + 8] = A[base + 8] - B[base + 8];\n    C[base + 12] = A[base + 12] - B[base + 12];\n}\n\n__kernel void taskParallelMul(__global float *A, __global float *B, __global float *C)\n{\n    int base = 2;\n\n    C[base + 0] = A[base + 0] * B[base + 0];\n    C[base + 4] = A[base + 4] * B[base + 4];\n    C[base + 8] = A[base + 8] * B[base + 8];\n    C[base + 12] = A[base + 12] * B[base + 12];\n}\n\n__kernel void taskParallelDiv(__global float *A, __global float *B, __global float *C)\n{\n    int base = 3;\n\n    C[base + 0] = A[base + 0] / B[base + 0];\n    C[base + 4] = A[base + 4] / B[base + 4];\n    C[base + 8] = A[base + 8] / B[base + 8];\n    C[base + 12] = A[base + 12] / B[base + 12];\n}\n")])])]),a("p",[a("strong",[e._v("List 4.11: Task parallel model - host taskParallel.c")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#include <stdio.h>\n#include <stdlib.h>\n\n#ifdef __APPLE__\n#include <OpenCL/opencl.h>\n#else\n#include <CL/cl.h>\n#endif\n\n#define MAX_SOURCE_SIZE (0x100000)\n\nint main()\n{\n    cl_platform_id platform_id = NULL;\n    cl_device_id device_id = NULL;\n    cl_context context = NULL;\n    cl_command_queue command_queue = NULL;\n    cl_mem Amobj = NULL;\n    cl_mem Bmobj = NULL;\n    cl_mem Cmobj = NULL;\n    cl_program program = NULL;\n    cl_kernel kernel[4] = {NULL, NULL, NULL, NULL};\n    cl_uint ret_num_devices;\n    cl_uint ret_num_platforms;\n    cl_int ret;\n\n    int i, j;\n    float *A;\n    float *B;\n    float *C;\n\n    A = (float *)malloc(4 * 4 * sizeof(float));\n    B = (float *)malloc(4 * 4 * sizeof(float));\n    C = (float *)malloc(4 * 4 * sizeof(float));\n\n    FILE *fp;\n    const char fileName[] = "./taskParallel.cl";\n    size_t source_size;\n    char *source_str;\n\n    /* Load kernel source file */\n    fp = fopen(fileName, "rb");\n    if (!fp)\n    {\n        fprintf(stderr, "Failed to load kernel.¥n");\n        exit(1);\n    }\n    source_str = (char *)malloc(MAX_SOURCE_SIZE);\n    source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);\n    fclose(fp);\n\n    /* Initialize input data */\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            A[i * 4 + j] = i * 4 + j + 1;\n            B[i * 4 + j] = j * 4 + i + 1;\n        }\n    }\n\n    /* Get platform/device information */\n    ret = clGetPlatformIDs(1, &platform_id, &ret_num_platforms);\n    ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &device_id, &ret_num_devices);\n\n    /* Create OpenCL Context */\n    context = clCreateContext(NULL, 1, &device_id, NULL, NULL, &ret);\n\n    /* Create command queue */\n    command_queue = clCreateCommandQueue(context, device_id, CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &ret);\n\n    /* Create buffer object */\n    Amobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * 4 * sizeof(float), NULL, &ret);\n    Bmobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * 4 * sizeof(float), NULL, &ret);\n    Cmobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * 4 * sizeof(float), NULL, &ret);\n\n    /* Copy input data to memory buffer */\n    ret = clEnqueueWriteBuffer(command_queue, Amobj, CL_TRUE, 0, 4 * 4 * sizeof(float), A, 0, NULL, NULL);\n    ret = clEnqueueWriteBuffer(command_queue, Bmobj, CL_TRUE, 0, 4 * 4 * sizeof(float), B, 0, NULL, NULL);\n\n    /* Create kernel from source */\n    program = clCreateProgramWithSource(context, 1, (const char **)&source_str, (const size_t *)&source_size, &ret);\n    ret = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);\n\n    /* Create task parallel OpenCL kernel */\n    kernel[0] = clCreateKernel(program, "taskParallelAdd", &ret);\n    kernel[1] = clCreateKernel(program, "taskParallelSub", &ret);\n    kernel[2] = clCreateKernel(program, "taskParallelMul", &ret);\n    kernel[3] = clCreateKernel(program, "taskParallelDiv", &ret);\n\n    /* Set OpenCL kernel arguments */\n    for (i = 0; i < 4; i++)\n    {\n        ret = clSetKernelArg(kernel[i], 0, sizeof(cl_mem), (void *)&Amobj);\n        ret = clSetKernelArg(kernel[i], 1, sizeof(cl_mem), (void *)&Bmobj);\n        ret = clSetKernelArg(kernel[i], 2, sizeof(cl_mem), (void *)&Cmobj);\n    }\n\n    /* Execute OpenCL kernel as task parallel */\n    for (i = 0; i < 4; i++)\n    {\n        ret = clEnqueueTask(command_queue, kernel[i], 0, NULL, NULL);\n    }\n\n    /* Copy result to host */\n    ret = clEnqueueReadBuffer(command_queue, Cmobj, CL_TRUE, 0, 4 * 4 * sizeof(float), C, 0, NULL, NULL);\n\n    /* Display result */\n    for (i = 0; i < 4; i++)\n    {\n        for (j = 0; j < 4; j++)\n        {\n            printf("%7.2f ", C[i * 4 + j]);\n        }\n        printf("¥n");\n    }\n\n    /* Finalization */\n    ret = clFlush(command_queue);\n    ret = clFinish(command_queue);\n    ret = clReleaseKernel(kernel[0]);\n    ret = clReleaseKernel(kernel[1]);\n    ret = clReleaseKernel(kernel[2]);\n    ret = clReleaseKernel(kernel[3]);\n    ret = clReleaseProgram(program);\n    ret = clReleaseMemObject(Amobj);\n    ret = clReleaseMemObject(Bmobj);\n    ret = clReleaseMemObject(Cmobj);\n    ret = clReleaseCommandQueue(command_queue);\n    ret = clReleaseContext(context);\n\n    free(source_str);\n\n    free(A);\n    free(B);\n    free(C);\n\n    return 0;\n}\n')])])]),a("p",[e._v("As you can see, the source codes are very similar. The only differences are in the kernels themselves, and the way to execute these kernels. In the data parallel model, the 4 arithmetic operations are grouped as one set of commands in a kernel, while in the task parallel model, 4 different kernels are implemented for each type of arithmetic operation.")]),e._v(" "),a("p",[e._v("At a glance, it may seem that since the task parallel model requires more code, that it also must perform more operations. However, regardless of which model is used for this problem, the number of operations being performed by the device is actually the same. Despite this fact, some problems are easier, and performance can vary by choosing one over the other, so the parallelization model must be considered wisely in the planning stage of the application.")]),e._v(" "),a("p",[e._v("We will now walkthrough the source code for the data parallel model.")]),e._v(" "),a("blockquote",[a("p",[e._v("001: __kernel void dataParallel(__global float * A, __global float * B, __global float * C)")])]),e._v(" "),a("p",[e._v("When the data parallel task is queued, work-items are created. Each of these work-items executes the same kernel in parallel.")]),e._v(" "),a("blockquote",[a("p",[e._v("003: int base = 4*get_global_id(0);")])]),e._v(" "),a("p",[e._v("The get_global_id(0) gets the global work-item ID, which is used to decide the data to process, so that each work-items can process different sets of data in parallel. In general, data parallel processing is done using the following steps.")]),e._v(" "),a("p",[e._v("1. Get work-item ID")]),e._v(" "),a("p",[e._v("2. Process the subset of data corresponding to the work-item ID")]),e._v(" "),a("p",[e._v("A block diagram of the process is shown in "),a("strong",[e._v("Figure 4.6")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Figure 4.6: Block diagram of the data-parallel model in relation to work-items")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(401),alt:""}})]),e._v(" "),a("p",[e._v('In this example, the global work-item is multiplied by 4 and stored in the variable "base". This value is used to decide which element of the array A and B gets processed.')]),e._v(" "),a("blockquote",[a("p",[e._v("005: C[base+0] = A[base+0] + B[base+0];")]),e._v(" "),a("p",[e._v("006: C[base+1] = A[base+1] - B[base+1];")]),e._v(" "),a("p",[e._v("007: C[base+2] = A[base+2] * B[base+2];")]),e._v(" "),a("p",[e._v("008: C[base+3] = A[base+3] / B[base+3];")])]),e._v(" "),a("p",[e._v('Since each work-item have different IDs, the variable "base" also have a different value for each work-item, which keeps the work-items from processing the same data. In this way, large amount of data can be processed concurrently.')]),e._v(" "),a("p",[e._v("We have discussed that numerous work items get created, but we have not touched upon how to decide the number of work-items to create. This is done in the following code segment from the host code.")]),e._v(" "),a("blockquote",[a("p",[e._v("090: size_t global_item_size = 4;")]),e._v(" "),a("p",[e._v("091: size_t local_item_size = 1;")]),e._v(" "),a("p",[e._v("092:")]),e._v(" "),a("p",[e._v("093: /* Execute OpenCL kernel as data parallel */")]),e._v(" "),a("p",[e._v("094: ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL,")]),e._v(" "),a("p",[e._v("095: &global_item_size, &local_item_size, 0, NULL, NULL); 090: size_t global_item_size = 4;")]),e._v(" "),a("p",[e._v("091: size_t local_item_size = 1;")]),e._v(" "),a("p",[e._v("092:")]),e._v(" "),a("p",[e._v("093: /* Execute OpenCL kernel as data parallel */")]),e._v(" "),a("p",[e._v("094: ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL,")]),e._v(" "),a("p",[e._v("095: &global_item_size, &local_item_size, 0, NULL, NULL);")])]),e._v(" "),a("p",[e._v("The clEnqueueNDRangeKernel() is an OpenCL API command used to queue data parallel tasks. The 5th and 6th arguments determine the work-item size. In this case, the global_item_size is set to 4, and the local_item_size is set to 1. The overall steps are summarized as follows.")]),e._v(" "),a("p",[e._v("1. Create work-items on the host")]),e._v(" "),a("p",[e._v("2. Process data corresponding to the global work item ID on the kernel")]),e._v(" "),a("p",[e._v("We will now walkthrough the source code for the task parallel model. In this model, different kernels are allowed to be executed in parallel. Note that different kernels are implemented for each of the 4 arithmetic operations.")]),e._v(" "),a("blockquote",[a("p",[e._v("096: /* Execute OpenCL kernel as task parallel */")]),e._v(" "),a("p",[e._v("097: for (i=0; i < 4; i++) {")]),e._v(" "),a("p",[e._v("098: ret = clEnqueueTask(command_queue, kernel[i], 0, NULL, NULL);")]),e._v(" "),a("p",[e._v("099: }")])]),e._v(" "),a("p",[e._v("The above code segment queues the 4 kernels.")]),e._v(" "),a("p",[e._v("In OpenCL, in order to execute a task parallel process, the out-of-order mode must be enabled when the command queue is created. Using this mode, the queued task does not wait until the previous task is finished if there are idle compute units available that can be executing that task.")]),e._v(" "),a("blockquote",[a("p",[e._v("067: /* Create command queue */")]),e._v(" "),a("p",[e._v("068: command_queue = clCreateCommandQueue(context, device_id, CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &ret);")])]),e._v(" "),a("p",[e._v("The block diagram of the nature of command queues and parallel execution are shown in "),a("strong",[e._v("Figure 4.7")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Figure 4.7: Command queues and parallel execution")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(402),alt:""}})]),e._v(" "),a("p",[e._v("The clEnqueueTask() is used as an example in the above figure, but a similar parallel processing could take place for other combinations of enqueue-functions, such as clEnqueueNDRangeKernel(), clEnqueueReadBuffer(), and clEnqueueWriteBuffer(). For example, since PCI Express supports simultaneous bi-directional memory transfers, queuing the clEnqueueReadBuffer() and clEnqueueWriteBuffer() can execute read and write commands simultaneously, provided that the commands are being performed by different processors. In the above diagram, we can expect the 4 tasks to be executed in parallel, since they are being queued in a command queue that has out-of-execution enabled.")]),e._v(" "),a("h2",{attrs:{id:"work-group"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#work-group"}},[e._v("#")]),e._v(" "),a("em",[e._v("Work Group")])]),e._v(" "),a("p",[e._v("The last section discussed the concept of work-items. This section will introduce the concept of work-groups.")]),e._v(" "),a("p",[e._v("Work-items are grouped together into work-groups. A work-group must consist of at least 1 work-item, and the maximum is dependent on the platform. The work-items within a work-group can synchronize, as well as share local memory with each other.")]),e._v(" "),a("p",[e._v("In order to implement a data parallel kernel, the number of work-groups must be specified in addition to the number of work-items. This is why 2 different parameters had to be sent to the clEnqueueNDRangeKernel() function.")]),e._v(" "),a("blockquote",[a("p",[e._v("090: size_t global_item_size = 4;")]),e._v(" "),a("p",[e._v("091: size_t local_item_size = 1;")])]),e._v(" "),a("p",[e._v("The above code means that each work-group is made up of 1 work-item, and that there are 4 work-groups to be processed.")]),e._v(" "),a("p",[e._v("The number of work-items per work-group is consistent throughout every work-group. If the number of work-items cannot be divided evenly among the work-groups, clEnqueueNDRangeKernel() fails, returning the error value CL_INVALID_WORK_GROUP_SIZE.")]),e._v(" "),a("p",[e._v("The code "),a("strong",[e._v("List 4.9")]),e._v(" only used the global work-item ID to process the kernel, but it is also possible to retrieve the local work-item ID corresponding to the work-group ID. The relationship between the global work-item ID, local work-item ID, and the work-group ID are shown below in "),a("strong",[e._v("Figure 4.8")]),e._v(". The function used to retrieve these ID's from within the kernel are shown in "),a("strong",[e._v("Table 4.1")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Figure 4.8: Work-group ID and Work-item ID")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(403),alt:""}})]),e._v(" "),a("p",[e._v("Since 2-D images or 3-D spaces are commonly processed, the work-items and work-groups can be specified in 2 or 3 dimensions. "),a("strong",[e._v("Figure 4.9")]),e._v(" shows an example where the work-group and the work-item are defined in 2-D.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 4.9: Work-group and work-item defined in 2-D")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(404),alt:""}})]),e._v(" "),a("p",[e._v("Since the work-group and the work-items can have up to 3 dimensions, the ID's that are used to index **** them also have 3 dimensions. The get_group_id(), get_global_id(), get_local_id() can each take an argument between 0 and 2, each corresponding to the dimension. The ID's for the work-items in "),a("strong",[e._v("Figure 4.9")]),e._v(" are shown below in "),a("strong",[e._v("Table 4.2")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Table 4.2: The ID's of the work-item in Figure 4.8")])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Call")]),e._v(" "),a("th",[e._v("Retrieved ID")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("get_group_id(0)")]),e._v(" "),a("td",[e._v("1")])]),e._v(" "),a("tr",[a("td",[e._v("get_group_id(1)")]),e._v(" "),a("td",[e._v("0")])]),e._v(" "),a("tr",[a("td",[e._v("get_global_id(0)")]),e._v(" "),a("td",[e._v("10")])]),e._v(" "),a("tr",[a("td",[e._v("get_global_id(1)")]),e._v(" "),a("td",[e._v("5")])]),e._v(" "),a("tr",[a("td",[e._v("get_local_id(0)")]),e._v(" "),a("td",[e._v("2")])]),e._v(" "),a("tr",[a("td",[e._v("get_local_id(1)")]),e._v(" "),a("td",[e._v("5")])])])]),e._v(" "),a("p",[e._v("Note that the index space dimension and the number of work-items per work-group can vary depending on the device. The maximum index space dimension can be obtained using the clGetDeviceInfo() function to get the value of CL_DEVICE_WORK_ITEM_DIMENSIONS, and the maximum number of work-items per work-group can be obtained by getting the value of CL_DEVICE_IMAGE_SUPPORT. The data-type of CL_DEVICE_MAX_WORK_ITEM is cl_uint, and for CL_DEVICE_IMAGE_SUPPORT, it is an array of type size_t.")]),e._v(" "),a("h2",{attrs:{id:"task-parallelism-and-event-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-parallelism-and-event-object"}},[e._v("#")]),e._v(" "),a("em",[e._v("Task Parallelism and Event Object")])]),e._v(" "),a("p",[e._v("The tasks placed in the command-queue are executed in parallel, but in cases where different tasks have data dependencies, they need to be executed sequentially. In OpenCL, the execution order can be set using an event object.")]),e._v(" "),a("p",[e._v('An event object contains information about the execution status of queued commands. This object is returned on all commands that start with "clEnqueue". In order to make sure task A executes before task B, the event object returned when task A is queued can be one of the inputs to task B, which keeps task B from executing until task A is completed.')]),e._v(" "),a("p",[e._v("For example, the function prototype for clPEnqueueTask() is shown below.")]),e._v(" "),a("blockquote",[a("p",[e._v("cl_int clEnqueueTask (cl_command_queue command_queue,")]),e._v(" "),a("p",[e._v("cl_kernel kernel,")]),e._v(" "),a("p",[e._v("cl_uint num_events_in_wait_list,")]),e._v(" "),a("p",[e._v("const cl_event *event_wait_list,")]),e._v(" "),a("p",[e._v("cl_event *event)")])]),e._v(" "),a("p",[e._v("The 4th argument is a list of events to be processed before this task can be run, and the 3rd argument is the number of events on the list. The 5th parameter is the event object returned by this task when it is placed in the queue.")]),e._v(" "),a("p",[a("strong",[e._v("List 4.12")]),e._v(" shows an example of how the event objects can be used. In this example, kernel_A, kernel_B, kernel_C, kernel_D can all be executed in any order, but these must be completed before kernel_E is executed.")]),e._v(" "),a("p",[a("strong",[e._v("List 4.12: Event object usage example")])]),e._v(" "),a("blockquote",[a("p",[e._v("clEnqueue events[4];")]),e._v(" "),a("p",[e._v("clEnqueueTask(command_queue, kernel_A, 0, NULL, &events[0]);")]),e._v(" "),a("p",[e._v("clEnqueueTask(command_queue, kernel_B, 0, NULL, &events[1]);")]),e._v(" "),a("p",[e._v("clEnqueueTask(command_queue, kernel_C, 0, NULL, &events[2]);")]),e._v(" "),a("p",[e._v("clEnqueueTask(command_queue, kernel_D, 0, NULL, &events[3]);")]),e._v(" "),a("p",[e._v("clEnqueueTask(command_queue, kernel_E, 4, events, NULL);")])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Column - Relationship between execution order and parallel execution")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("p",[e._v('In OpenCL, the tasks placed in the command queue are executed regardless of the order in which it is placed in the queue. In the specification sheet for parallel processors, there is usually a section on "order". When working on parallel processing algorithms, the concept of "order" and "parallel" need to be fully understood. ')]),a("p",[e._v('First, we will discuss the concept of "order". As an example, let\'s assume the following 4 tasks are performed sequentially in the order shown below. ')]),a("p",[e._v("(A) → (B) → (C) → (D) ")])])]),e._v(" "),a("tr",[a("td",[a("img",{attrs:{src:n(405),alt:""}})])]),e._v(" "),a("tr",[a("td",[a("p",[e._v("Now, we will switch the order in which task B and C are performed. ")]),a("p",[e._v("(A) → (C) → (B) → (D) ")]),a("p",[e._v("If tasks B and C are not dependent on each other, the two sets of tasks will result in the same output. If they are not, the two sets of tasks will not yield the correct result. This problem of whether a certain set of tasks can be performed in different order is a process-dependent problem. ")]),a("p",[e._v("Parallel processing is a type of optimization that deals with changing the order of tasks. For example, let's assume tasks B and C are processed in parallel. ")]),a("p",[e._v("In this case, task B may finish before task C, but task D waits for the results of both tasks B and C. This processing is only allowed in the case where the tasks B and C do not depend on each other. Thus, if task C must be performed after task B, then the 2 tasks cannot be processed in parallel. ")]),a("p",[e._v("On the other hand, it may make more sense to implement all the tasks in a single thread. Also, if the tasks are executed on a single-core processor, all the tasks must be performed sequentially. These need to be considered when implementing an algorithm. ")]),a("p",[e._v("In essence, two problems must be solved. One is whether some tasks can be executed out of order, and the other is whether to process the tasks in parallel. ")]),a("p",[e._v("• Tasks must be executed in a specific order = Cannot be parallelized ")]),a("p",[e._v("• Tasks can be executed out of order = Can be parallelized ")]),a("p",[e._v("Specifications are written to be a general reference of the capabilities, and do not deal with the actual implementation. Decision to execute certain tasks in parallel is thus not discussed inside the specification. Instead, it contains information such as how certain tasks are guaranteed to be processed in order. ")]),a("p",[e._v('Explanations on "ordering" is often times difficult to follow (Example: PowerPC\'s Storage Access Ordering), but often times, treating "order" as the basis when implementing parallel algorithms can clear up existing bottlenecks in the program. ')]),a("p",[e._v('For example, OpenMP\'s "parallel" construct specifies the code segment to be executed in parallel, but placing this construct in a single-core processor will not process the code segment in parallel. In this case, one may wonder if it meets OpenMP\'s specification. If you think about the "parallel" construct as something that tells the compiler and the processors that the loops can be executed out-of-order, it clears up the definition, since it means that the ordering can be changed or the tasks can be run parallel, but that they do not have to be. ')])])])])])])}),[],!1,null,null,null);t.default=o.exports}}]);